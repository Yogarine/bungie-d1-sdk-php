<?php
/**
 * UnofficialApi
 * PHP version 5
 *
 * @category Class
 * @package  Bungie\D1
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Unofficial Bungie.net API for Destiny 1
 *
 * These are legacy endpoints for Destiny 1 that are no longer supported officially by Bungie.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: lowlines89@gmail.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 3.3.4-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Bungie\D1\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Bungie\D1\ApiException;
use Bungie\D1\Configuration;
use Bungie\D1\HeaderSelector;
use Bungie\D1\ObjectSerializer;

/**
 * UnofficialApi Class Doc Comment
 *
 * @category Class
 * @package  Bungie\D1
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class UnofficialApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation equipItem
     *
     * @param  \Bungie\D1\Model\inline_object_1 $inlineObject1 inlineObject1 (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20036
     */
    public function equipItem($inlineObject1 = null)
    {
        list($response) = $this->equipItemWithHttpInfo($inlineObject1);
        return $response;
    }

    /**
     * Operation equipItemWithHttpInfo
     *
     * @param  \Bungie\D1\Model\inline_object_1 $inlineObject1 (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20036, HTTP status code, HTTP response headers (array of strings)
     */
    public function equipItemWithHttpInfo($inlineObject1 = null)
    {
        $request = $this->equipItemRequest($inlineObject1);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20036' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20036', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20036';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20036',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation equipItemAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\inline_object_1 $inlineObject1 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function equipItemAsync($inlineObject1 = null)
    {
        return $this->equipItemAsyncWithHttpInfo($inlineObject1)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation equipItemAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\inline_object_1 $inlineObject1 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function equipItemAsyncWithHttpInfo($inlineObject1 = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20036';
        $request = $this->equipItemRequest($inlineObject1);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'equipItem'
     *
     * @param  \Bungie\D1\Model\inline_object_1 $inlineObject1 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function equipItemRequest($inlineObject1 = null)
    {

        $resourcePath = '/Destiny/EquipItem/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($inlineObject1)) {
            $_tempBody = $inlineObject1;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation equipItems
     *
     * @param  \Bungie\D1\Model\inline_object_2 $inlineObject2 inlineObject2 (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20037
     */
    public function equipItems($inlineObject2 = null)
    {
        list($response) = $this->equipItemsWithHttpInfo($inlineObject2);
        return $response;
    }

    /**
     * Operation equipItemsWithHttpInfo
     *
     * @param  \Bungie\D1\Model\inline_object_2 $inlineObject2 (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20037, HTTP status code, HTTP response headers (array of strings)
     */
    public function equipItemsWithHttpInfo($inlineObject2 = null)
    {
        $request = $this->equipItemsRequest($inlineObject2);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20037' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20037', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20037';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20037',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation equipItemsAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\inline_object_2 $inlineObject2 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function equipItemsAsync($inlineObject2 = null)
    {
        return $this->equipItemsAsyncWithHttpInfo($inlineObject2)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation equipItemsAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\inline_object_2 $inlineObject2 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function equipItemsAsyncWithHttpInfo($inlineObject2 = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20037';
        $request = $this->equipItemsRequest($inlineObject2);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'equipItems'
     *
     * @param  \Bungie\D1\Model\inline_object_2 $inlineObject2 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function equipItemsRequest($inlineObject2 = null)
    {

        $resourcePath = '/Destiny/EquipItems/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($inlineObject2)) {
            $_tempBody = $inlineObject2;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccount
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse2007
     */
    public function getAccount($membershipType, $destinyMembershipId, $definitions = null)
    {
        list($response) = $this->getAccountWithHttpInfo($membershipType, $destinyMembershipId, $definitions);
        return $response;
    }

    /**
     * Operation getAccountWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse2007, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountWithHttpInfo($membershipType, $destinyMembershipId, $definitions = null)
    {
        $request = $this->getAccountRequest($membershipType, $destinyMembershipId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse2007' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse2007', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse2007';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse2007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAsync($membershipType, $destinyMembershipId, $definitions = null)
    {
        return $this->getAccountAsyncWithHttpInfo($membershipType, $destinyMembershipId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAsyncWithHttpInfo($membershipType, $destinyMembershipId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse2007';
        $request = $this->getAccountRequest($membershipType, $destinyMembershipId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccount'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccountRequest($membershipType, $destinyMembershipId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getAccount'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getAccount'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Account/{destinyMembershipId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccountSummary
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse2008
     */
    public function getAccountSummary($membershipType, $destinyMembershipId, $definitions = null)
    {
        list($response) = $this->getAccountSummaryWithHttpInfo($membershipType, $destinyMembershipId, $definitions);
        return $response;
    }

    /**
     * Operation getAccountSummaryWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse2008, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountSummaryWithHttpInfo($membershipType, $destinyMembershipId, $definitions = null)
    {
        $request = $this->getAccountSummaryRequest($membershipType, $destinyMembershipId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse2008' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse2008', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse2008';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse2008',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountSummaryAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountSummaryAsync($membershipType, $destinyMembershipId, $definitions = null)
    {
        return $this->getAccountSummaryAsyncWithHttpInfo($membershipType, $destinyMembershipId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountSummaryAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountSummaryAsyncWithHttpInfo($membershipType, $destinyMembershipId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse2008';
        $request = $this->getAccountSummaryRequest($membershipType, $destinyMembershipId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountSummary'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccountSummaryRequest($membershipType, $destinyMembershipId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getAccountSummary'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getAccountSummary'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Account/{destinyMembershipId}/Summary/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getActivityBlob
     *
     * @param  string $param1 param1 (required)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20050
     */
    public function getActivityBlob($param1)
    {
        list($response) = $this->getActivityBlobWithHttpInfo($param1);
        return $response;
    }

    /**
     * Operation getActivityBlobWithHttpInfo
     *
     * @param  string $param1 (required)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20050, HTTP status code, HTTP response headers (array of strings)
     */
    public function getActivityBlobWithHttpInfo($param1)
    {
        $request = $this->getActivityBlobRequest($param1);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20050' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20050', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20050';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20050',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getActivityBlobAsync
     *
     * 
     *
     * @param  string $param1 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityBlobAsync($param1)
    {
        return $this->getActivityBlobAsyncWithHttpInfo($param1)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getActivityBlobAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $param1 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityBlobAsyncWithHttpInfo($param1)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20050';
        $request = $this->getActivityBlobRequest($param1);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getActivityBlob'
     *
     * @param  string $param1 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getActivityBlobRequest($param1)
    {
        // verify the required parameter 'param1' is set
        if ($param1 === null || (is_array($param1) && count($param1) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $param1 when calling getActivityBlob'
            );
        }

        $resourcePath = '/Destiny/Stats/ActivityBlob/{param1}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($param1 !== null) {
            $resourcePath = str_replace(
                '{' . 'param1' . '}',
                ObjectSerializer::toPathValue($param1),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getActivityHistory
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId characterId (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType $mode Game mode to return. Required. (optional)
     * @param  int $count The number of results to return. (optional)
     * @param  int $page The current page to return. Starts at 1. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20043
     */
    public function getActivityHistory($membershipType, $destinyMembershipId, $characterId, $mode = null, $count = null, $page = null, $definitions = null)
    {
        list($response) = $this->getActivityHistoryWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $mode, $count, $page, $definitions);
        return $response;
    }

    /**
     * Operation getActivityHistoryWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType $mode Game mode to return. Required. (optional)
     * @param  int $count The number of results to return. (optional)
     * @param  int $page The current page to return. Starts at 1. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20043, HTTP status code, HTTP response headers (array of strings)
     */
    public function getActivityHistoryWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $mode = null, $count = null, $page = null, $definitions = null)
    {
        $request = $this->getActivityHistoryRequest($membershipType, $destinyMembershipId, $characterId, $mode, $count, $page, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20043' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20043', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20043';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20043',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getActivityHistoryAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType $mode Game mode to return. Required. (optional)
     * @param  int $count The number of results to return. (optional)
     * @param  int $page The current page to return. Starts at 1. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityHistoryAsync($membershipType, $destinyMembershipId, $characterId, $mode = null, $count = null, $page = null, $definitions = null)
    {
        return $this->getActivityHistoryAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $mode, $count, $page, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getActivityHistoryAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType $mode Game mode to return. Required. (optional)
     * @param  int $count The number of results to return. (optional)
     * @param  int $page The current page to return. Starts at 1. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityHistoryAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $mode = null, $count = null, $page = null, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20043';
        $request = $this->getActivityHistoryRequest($membershipType, $destinyMembershipId, $characterId, $mode, $count, $page, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getActivityHistory'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType $mode Game mode to return. Required. (optional)
     * @param  int $count The number of results to return. (optional)
     * @param  int $page The current page to return. Starts at 1. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getActivityHistoryRequest($membershipType, $destinyMembershipId, $characterId, $mode = null, $count = null, $page = null, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getActivityHistory'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getActivityHistory'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getActivityHistory'
            );
        }

        $resourcePath = '/Destiny/Stats/ActivityHistory/{membershipType}/{destinyMembershipId}/{characterId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdvisorsForAccount
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse2001
     */
    public function getAdvisorsForAccount($membershipType, $destinyMembershipId, $definitions = null)
    {
        list($response) = $this->getAdvisorsForAccountWithHttpInfo($membershipType, $destinyMembershipId, $definitions);
        return $response;
    }

    /**
     * Operation getAdvisorsForAccountWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdvisorsForAccountWithHttpInfo($membershipType, $destinyMembershipId, $definitions = null)
    {
        $request = $this->getAdvisorsForAccountRequest($membershipType, $destinyMembershipId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse2001' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse2001', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse2001';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdvisorsForAccountAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdvisorsForAccountAsync($membershipType, $destinyMembershipId, $definitions = null)
    {
        return $this->getAdvisorsForAccountAsyncWithHttpInfo($membershipType, $destinyMembershipId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdvisorsForAccountAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdvisorsForAccountAsyncWithHttpInfo($membershipType, $destinyMembershipId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse2001';
        $request = $this->getAdvisorsForAccountRequest($membershipType, $destinyMembershipId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdvisorsForAccount'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAdvisorsForAccountRequest($membershipType, $destinyMembershipId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getAdvisorsForAccount'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getAdvisorsForAccount'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Account/{destinyMembershipId}/Advisors/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdvisorsForCharacter
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20028
     */
    public function getAdvisorsForCharacter($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        list($response) = $this->getAdvisorsForCharacterWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions);
        return $response;
    }

    /**
     * Operation getAdvisorsForCharacterWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20028, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdvisorsForCharacterWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $request = $this->getAdvisorsForCharacterRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20028' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20028', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20028';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20028',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdvisorsForCharacterAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdvisorsForCharacterAsync($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        return $this->getAdvisorsForCharacterAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdvisorsForCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdvisorsForCharacterAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20028';
        $request = $this->getAdvisorsForCharacterRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdvisorsForCharacter'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAdvisorsForCharacterRequest($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getAdvisorsForCharacter'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getAdvisorsForCharacter'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getAdvisorsForCharacter'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Advisors/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdvisorsForCharacterV2
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse2002
     */
    public function getAdvisorsForCharacterV2($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        list($response) = $this->getAdvisorsForCharacterV2WithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions);
        return $response;
    }

    /**
     * Operation getAdvisorsForCharacterV2WithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdvisorsForCharacterV2WithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $request = $this->getAdvisorsForCharacterV2Request($membershipType, $destinyMembershipId, $characterId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse2002' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse2002', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse2002';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdvisorsForCharacterV2Async
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdvisorsForCharacterV2Async($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        return $this->getAdvisorsForCharacterV2AsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdvisorsForCharacterV2AsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdvisorsForCharacterV2AsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse2002';
        $request = $this->getAdvisorsForCharacterV2Request($membershipType, $destinyMembershipId, $characterId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdvisorsForCharacterV2'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAdvisorsForCharacterV2Request($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getAdvisorsForCharacterV2'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getAdvisorsForCharacterV2'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getAdvisorsForCharacterV2'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Advisors/V2/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdvisorsForCurrentCharacter
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20027
     */
    public function getAdvisorsForCurrentCharacter($membershipType, $characterId, $definitions = null)
    {
        list($response) = $this->getAdvisorsForCurrentCharacterWithHttpInfo($membershipType, $characterId, $definitions);
        return $response;
    }

    /**
     * Operation getAdvisorsForCurrentCharacterWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20027, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdvisorsForCurrentCharacterWithHttpInfo($membershipType, $characterId, $definitions = null)
    {
        $request = $this->getAdvisorsForCurrentCharacterRequest($membershipType, $characterId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20027' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20027', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20027';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20027',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdvisorsForCurrentCharacterAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdvisorsForCurrentCharacterAsync($membershipType, $characterId, $definitions = null)
    {
        return $this->getAdvisorsForCurrentCharacterAsyncWithHttpInfo($membershipType, $characterId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdvisorsForCurrentCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdvisorsForCurrentCharacterAsyncWithHttpInfo($membershipType, $characterId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20027';
        $request = $this->getAdvisorsForCurrentCharacterRequest($membershipType, $characterId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdvisorsForCurrentCharacter'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAdvisorsForCurrentCharacterRequest($membershipType, $characterId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getAdvisorsForCurrentCharacter'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getAdvisorsForCurrentCharacter'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/MyAccount/Character/{characterId}/Advisors/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllItemsSummary
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse2006
     */
    public function getAllItemsSummary($membershipType, $destinyMembershipId, $definitions = null)
    {
        list($response) = $this->getAllItemsSummaryWithHttpInfo($membershipType, $destinyMembershipId, $definitions);
        return $response;
    }

    /**
     * Operation getAllItemsSummaryWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse2006, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllItemsSummaryWithHttpInfo($membershipType, $destinyMembershipId, $definitions = null)
    {
        $request = $this->getAllItemsSummaryRequest($membershipType, $destinyMembershipId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse2006' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse2006', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse2006';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse2006',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllItemsSummaryAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllItemsSummaryAsync($membershipType, $destinyMembershipId, $definitions = null)
    {
        return $this->getAllItemsSummaryAsyncWithHttpInfo($membershipType, $destinyMembershipId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllItemsSummaryAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllItemsSummaryAsyncWithHttpInfo($membershipType, $destinyMembershipId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse2006';
        $request = $this->getAllItemsSummaryRequest($membershipType, $destinyMembershipId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllItemsSummary'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllItemsSummaryRequest($membershipType, $destinyMembershipId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getAllItemsSummary'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getAllItemsSummary'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Account/{destinyMembershipId}/Items/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllVendorsForCurrentCharacter
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20020
     */
    public function getAllVendorsForCurrentCharacter($membershipType, $characterId, $definitions = null)
    {
        list($response) = $this->getAllVendorsForCurrentCharacterWithHttpInfo($membershipType, $characterId, $definitions);
        return $response;
    }

    /**
     * Operation getAllVendorsForCurrentCharacterWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20020, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllVendorsForCurrentCharacterWithHttpInfo($membershipType, $characterId, $definitions = null)
    {
        $request = $this->getAllVendorsForCurrentCharacterRequest($membershipType, $characterId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20020' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20020', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20020';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20020',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllVendorsForCurrentCharacterAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllVendorsForCurrentCharacterAsync($membershipType, $characterId, $definitions = null)
    {
        return $this->getAllVendorsForCurrentCharacterAsyncWithHttpInfo($membershipType, $characterId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllVendorsForCurrentCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllVendorsForCurrentCharacterAsyncWithHttpInfo($membershipType, $characterId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20020';
        $request = $this->getAllVendorsForCurrentCharacterRequest($membershipType, $characterId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllVendorsForCurrentCharacter'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllVendorsForCurrentCharacterRequest($membershipType, $characterId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getAllVendorsForCurrentCharacter'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getAllVendorsForCurrentCharacter'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/MyAccount/Character/{characterId}/Vendors/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBondAdvisors
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20031
     */
    public function getBondAdvisors($membershipType, $definitions = null)
    {
        list($response) = $this->getBondAdvisorsWithHttpInfo($membershipType, $definitions);
        return $response;
    }

    /**
     * Operation getBondAdvisorsWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20031, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBondAdvisorsWithHttpInfo($membershipType, $definitions = null)
    {
        $request = $this->getBondAdvisorsRequest($membershipType, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20031' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20031', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20031';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20031',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBondAdvisorsAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBondAdvisorsAsync($membershipType, $definitions = null)
    {
        return $this->getBondAdvisorsAsyncWithHttpInfo($membershipType, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBondAdvisorsAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBondAdvisorsAsyncWithHttpInfo($membershipType, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20031';
        $request = $this->getBondAdvisorsRequest($membershipType, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBondAdvisors'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBondAdvisorsRequest($membershipType, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getBondAdvisors'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/MyAccount/Advisors/Bonds/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCharacter
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20012
     */
    public function getCharacter($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        list($response) = $this->getCharacterWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions);
        return $response;
    }

    /**
     * Operation getCharacterWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20012, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCharacterWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $request = $this->getCharacterRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20012' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20012', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20012';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20012',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCharacterAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCharacterAsync($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        return $this->getCharacterAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCharacterAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20012';
        $request = $this->getCharacterRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCharacter'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCharacterRequest($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getCharacter'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getCharacter'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getCharacter'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Complete/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCharacterActivities
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20016
     */
    public function getCharacterActivities($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        list($response) = $this->getCharacterActivitiesWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions);
        return $response;
    }

    /**
     * Operation getCharacterActivitiesWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20016, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCharacterActivitiesWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $request = $this->getCharacterActivitiesRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20016' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20016', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20016';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20016',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCharacterActivitiesAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCharacterActivitiesAsync($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        return $this->getCharacterActivitiesAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCharacterActivitiesAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCharacterActivitiesAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20016';
        $request = $this->getCharacterActivitiesRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCharacterActivities'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCharacterActivitiesRequest($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getCharacterActivities'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getCharacterActivities'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getCharacterActivities'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Activities/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCharacterInventory
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20013
     */
    public function getCharacterInventory($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        list($response) = $this->getCharacterInventoryWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions);
        return $response;
    }

    /**
     * Operation getCharacterInventoryWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20013, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCharacterInventoryWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $request = $this->getCharacterInventoryRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20013' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20013', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20013';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20013',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCharacterInventoryAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCharacterInventoryAsync($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        return $this->getCharacterInventoryAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCharacterInventoryAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCharacterInventoryAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20013';
        $request = $this->getCharacterInventoryRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCharacterInventory'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCharacterInventoryRequest($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getCharacterInventory'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getCharacterInventory'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getCharacterInventory'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Inventory/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCharacterInventorySummary
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20014
     */
    public function getCharacterInventorySummary($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        list($response) = $this->getCharacterInventorySummaryWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions);
        return $response;
    }

    /**
     * Operation getCharacterInventorySummaryWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20014, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCharacterInventorySummaryWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $request = $this->getCharacterInventorySummaryRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20014' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20014', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20014';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20014',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCharacterInventorySummaryAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCharacterInventorySummaryAsync($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        return $this->getCharacterInventorySummaryAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCharacterInventorySummaryAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCharacterInventorySummaryAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20014';
        $request = $this->getCharacterInventorySummaryRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCharacterInventorySummary'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCharacterInventorySummaryRequest($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getCharacterInventorySummary'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getCharacterInventorySummary'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getCharacterInventorySummary'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Inventory/Summary/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCharacterProgression
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20017
     */
    public function getCharacterProgression($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        list($response) = $this->getCharacterProgressionWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions);
        return $response;
    }

    /**
     * Operation getCharacterProgressionWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20017, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCharacterProgressionWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $request = $this->getCharacterProgressionRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20017' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20017', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20017';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20017',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCharacterProgressionAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCharacterProgressionAsync($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        return $this->getCharacterProgressionAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCharacterProgressionAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCharacterProgressionAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20017';
        $request = $this->getCharacterProgressionRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCharacterProgression'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCharacterProgressionRequest($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getCharacterProgression'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getCharacterProgression'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getCharacterProgression'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Progression/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCharacterSummary
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20011
     */
    public function getCharacterSummary($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        list($response) = $this->getCharacterSummaryWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions);
        return $response;
    }

    /**
     * Operation getCharacterSummaryWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20011, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCharacterSummaryWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $request = $this->getCharacterSummaryRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20011' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20011', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20011';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20011',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCharacterSummaryAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCharacterSummaryAsync($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        return $this->getCharacterSummaryAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCharacterSummaryAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCharacterSummaryAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20011';
        $request = $this->getCharacterSummaryRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCharacterSummary'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCharacterSummaryRequest($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getCharacterSummary'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getCharacterSummary'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getCharacterSummary'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getClanLeaderboards
     *
     * @param  int $clanId A valid clan ID. (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $statid statid (optional)
     * @param  string $maxtop maxtop (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20046
     */
    public function getClanLeaderboards($clanId, $modes = null, $statid = null, $maxtop = null)
    {
        list($response) = $this->getClanLeaderboardsWithHttpInfo($clanId, $modes, $statid, $maxtop);
        return $response;
    }

    /**
     * Operation getClanLeaderboardsWithHttpInfo
     *
     * @param  int $clanId A valid clan ID. (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $statid (optional)
     * @param  string $maxtop (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20046, HTTP status code, HTTP response headers (array of strings)
     */
    public function getClanLeaderboardsWithHttpInfo($clanId, $modes = null, $statid = null, $maxtop = null)
    {
        $request = $this->getClanLeaderboardsRequest($clanId, $modes, $statid, $maxtop);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20046' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20046', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20046';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20046',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getClanLeaderboardsAsync
     *
     * 
     *
     * @param  int $clanId A valid clan ID. (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $statid (optional)
     * @param  string $maxtop (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClanLeaderboardsAsync($clanId, $modes = null, $statid = null, $maxtop = null)
    {
        return $this->getClanLeaderboardsAsyncWithHttpInfo($clanId, $modes, $statid, $maxtop)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getClanLeaderboardsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $clanId A valid clan ID. (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $statid (optional)
     * @param  string $maxtop (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClanLeaderboardsAsyncWithHttpInfo($clanId, $modes = null, $statid = null, $maxtop = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20046';
        $request = $this->getClanLeaderboardsRequest($clanId, $modes, $statid, $maxtop);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getClanLeaderboards'
     *
     * @param  int $clanId A valid clan ID. (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $statid (optional)
     * @param  string $maxtop (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getClanLeaderboardsRequest($clanId, $modes = null, $statid = null, $maxtop = null)
    {
        // verify the required parameter 'clanId' is set
        if ($clanId === null || (is_array($clanId) && count($clanId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $clanId when calling getClanLeaderboards'
            );
        }

        $resourcePath = '/Destiny/Stats/ClanLeaderboards/{clanId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, 'multi', true);
        }
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($statid !== null) {
            $queryParams['statid'] = ObjectSerializer::toQueryValue($statid);
        }
        // query params
        if ($maxtop !== null) {
            $queryParams['maxtop'] = ObjectSerializer::toQueryValue($maxtop);
        }

        // path params
        if ($clanId !== null) {
            $resourcePath = str_replace(
                '{' . 'clanId' . '}',
                ObjectSerializer::toPathValue($clanId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinyAggregateActivityStats
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20051
     */
    public function getDestinyAggregateActivityStats($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        list($response) = $this->getDestinyAggregateActivityStatsWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions);
        return $response;
    }

    /**
     * Operation getDestinyAggregateActivityStatsWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20051, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinyAggregateActivityStatsWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $request = $this->getDestinyAggregateActivityStatsRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20051' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20051', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20051';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20051',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinyAggregateActivityStatsAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyAggregateActivityStatsAsync($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        return $this->getDestinyAggregateActivityStatsAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinyAggregateActivityStatsAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyAggregateActivityStatsAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20051';
        $request = $this->getDestinyAggregateActivityStatsRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinyAggregateActivityStats'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinyAggregateActivityStatsRequest($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getDestinyAggregateActivityStats'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getDestinyAggregateActivityStats'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getDestinyAggregateActivityStats'
            );
        }

        $resourcePath = '/Destiny/Stats/AggregateActivityStats/{membershipType}/{destinyMembershipId}/{characterId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinyExplorerItems
     *
     * @param  int $count The number of results to return. Default is 10. (optional)
     * @param  string $name Filter by name. (optional)
     * @param  \Bungie\D1\Model\Destiny\ExplorerOrderBy $order Order results. (optional)
     * @param  \Bungie\D1\Model\TierType $rarity Filter by item rarity. (optional)
     * @param  \Bungie\D1\Model\DamageType[] $damageTypes Filter by damage type. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $rarity2 rarity2 (optional)
     * @param  string $step step (optional)
     * @param  string $categories categories (optional)
     * @param  string $weaponPerformance weaponPerformance (optional)
     * @param  string $impactEffects impactEffects (optional)
     * @param  string $guardianAttributes guardianAttributes (optional)
     * @param  string $lightAbilities lightAbilities (optional)
     * @param  string $damageTypes2 damageTypes2 (optional)
     * @param  string $matchrandomsteps matchrandomsteps (optional)
     * @param  string $definitions2 definitions2 (optional)
     * @param  string $sourcecat sourcecat (optional)
     * @param  string $sourcehash sourcehash (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20057
     */
    public function getDestinyExplorerItems($count = null, $name = null, $order = null, $rarity = null, $damageTypes = null, $definitions = null, $rarity2 = null, $step = null, $categories = null, $weaponPerformance = null, $impactEffects = null, $guardianAttributes = null, $lightAbilities = null, $damageTypes2 = null, $matchrandomsteps = null, $definitions2 = null, $sourcecat = null, $sourcehash = null)
    {
        list($response) = $this->getDestinyExplorerItemsWithHttpInfo($count, $name, $order, $rarity, $damageTypes, $definitions, $rarity2, $step, $categories, $weaponPerformance, $impactEffects, $guardianAttributes, $lightAbilities, $damageTypes2, $matchrandomsteps, $definitions2, $sourcecat, $sourcehash);
        return $response;
    }

    /**
     * Operation getDestinyExplorerItemsWithHttpInfo
     *
     * @param  int $count The number of results to return. Default is 10. (optional)
     * @param  string $name Filter by name. (optional)
     * @param  \Bungie\D1\Model\Destiny\ExplorerOrderBy $order Order results. (optional)
     * @param  \Bungie\D1\Model\TierType $rarity Filter by item rarity. (optional)
     * @param  \Bungie\D1\Model\DamageType[] $damageTypes Filter by damage type. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $rarity2 (optional)
     * @param  string $step (optional)
     * @param  string $categories (optional)
     * @param  string $weaponPerformance (optional)
     * @param  string $impactEffects (optional)
     * @param  string $guardianAttributes (optional)
     * @param  string $lightAbilities (optional)
     * @param  string $damageTypes2 (optional)
     * @param  string $matchrandomsteps (optional)
     * @param  string $definitions2 (optional)
     * @param  string $sourcecat (optional)
     * @param  string $sourcehash (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20057, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinyExplorerItemsWithHttpInfo($count = null, $name = null, $order = null, $rarity = null, $damageTypes = null, $definitions = null, $rarity2 = null, $step = null, $categories = null, $weaponPerformance = null, $impactEffects = null, $guardianAttributes = null, $lightAbilities = null, $damageTypes2 = null, $matchrandomsteps = null, $definitions2 = null, $sourcecat = null, $sourcehash = null)
    {
        $request = $this->getDestinyExplorerItemsRequest($count, $name, $order, $rarity, $damageTypes, $definitions, $rarity2, $step, $categories, $weaponPerformance, $impactEffects, $guardianAttributes, $lightAbilities, $damageTypes2, $matchrandomsteps, $definitions2, $sourcecat, $sourcehash);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20057' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20057', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20057';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20057',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinyExplorerItemsAsync
     *
     * 
     *
     * @param  int $count The number of results to return. Default is 10. (optional)
     * @param  string $name Filter by name. (optional)
     * @param  \Bungie\D1\Model\Destiny\ExplorerOrderBy $order Order results. (optional)
     * @param  \Bungie\D1\Model\TierType $rarity Filter by item rarity. (optional)
     * @param  \Bungie\D1\Model\DamageType[] $damageTypes Filter by damage type. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $rarity2 (optional)
     * @param  string $step (optional)
     * @param  string $categories (optional)
     * @param  string $weaponPerformance (optional)
     * @param  string $impactEffects (optional)
     * @param  string $guardianAttributes (optional)
     * @param  string $lightAbilities (optional)
     * @param  string $damageTypes2 (optional)
     * @param  string $matchrandomsteps (optional)
     * @param  string $definitions2 (optional)
     * @param  string $sourcecat (optional)
     * @param  string $sourcehash (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyExplorerItemsAsync($count = null, $name = null, $order = null, $rarity = null, $damageTypes = null, $definitions = null, $rarity2 = null, $step = null, $categories = null, $weaponPerformance = null, $impactEffects = null, $guardianAttributes = null, $lightAbilities = null, $damageTypes2 = null, $matchrandomsteps = null, $definitions2 = null, $sourcecat = null, $sourcehash = null)
    {
        return $this->getDestinyExplorerItemsAsyncWithHttpInfo($count, $name, $order, $rarity, $damageTypes, $definitions, $rarity2, $step, $categories, $weaponPerformance, $impactEffects, $guardianAttributes, $lightAbilities, $damageTypes2, $matchrandomsteps, $definitions2, $sourcecat, $sourcehash)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinyExplorerItemsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $count The number of results to return. Default is 10. (optional)
     * @param  string $name Filter by name. (optional)
     * @param  \Bungie\D1\Model\Destiny\ExplorerOrderBy $order Order results. (optional)
     * @param  \Bungie\D1\Model\TierType $rarity Filter by item rarity. (optional)
     * @param  \Bungie\D1\Model\DamageType[] $damageTypes Filter by damage type. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $rarity2 (optional)
     * @param  string $step (optional)
     * @param  string $categories (optional)
     * @param  string $weaponPerformance (optional)
     * @param  string $impactEffects (optional)
     * @param  string $guardianAttributes (optional)
     * @param  string $lightAbilities (optional)
     * @param  string $damageTypes2 (optional)
     * @param  string $matchrandomsteps (optional)
     * @param  string $definitions2 (optional)
     * @param  string $sourcecat (optional)
     * @param  string $sourcehash (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyExplorerItemsAsyncWithHttpInfo($count = null, $name = null, $order = null, $rarity = null, $damageTypes = null, $definitions = null, $rarity2 = null, $step = null, $categories = null, $weaponPerformance = null, $impactEffects = null, $guardianAttributes = null, $lightAbilities = null, $damageTypes2 = null, $matchrandomsteps = null, $definitions2 = null, $sourcecat = null, $sourcehash = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20057';
        $request = $this->getDestinyExplorerItemsRequest($count, $name, $order, $rarity, $damageTypes, $definitions, $rarity2, $step, $categories, $weaponPerformance, $impactEffects, $guardianAttributes, $lightAbilities, $damageTypes2, $matchrandomsteps, $definitions2, $sourcecat, $sourcehash);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinyExplorerItems'
     *
     * @param  int $count The number of results to return. Default is 10. (optional)
     * @param  string $name Filter by name. (optional)
     * @param  \Bungie\D1\Model\Destiny\ExplorerOrderBy $order Order results. (optional)
     * @param  \Bungie\D1\Model\TierType $rarity Filter by item rarity. (optional)
     * @param  \Bungie\D1\Model\DamageType[] $damageTypes Filter by damage type. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $rarity2 (optional)
     * @param  string $step (optional)
     * @param  string $categories (optional)
     * @param  string $weaponPerformance (optional)
     * @param  string $impactEffects (optional)
     * @param  string $guardianAttributes (optional)
     * @param  string $lightAbilities (optional)
     * @param  string $damageTypes2 (optional)
     * @param  string $matchrandomsteps (optional)
     * @param  string $definitions2 (optional)
     * @param  string $sourcecat (optional)
     * @param  string $sourcehash (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinyExplorerItemsRequest($count = null, $name = null, $order = null, $rarity = null, $damageTypes = null, $definitions = null, $rarity2 = null, $step = null, $categories = null, $weaponPerformance = null, $impactEffects = null, $guardianAttributes = null, $lightAbilities = null, $damageTypes2 = null, $matchrandomsteps = null, $definitions2 = null, $sourcecat = null, $sourcehash = null)
    {

        $resourcePath = '/Destiny/Explorer/Items/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($rarity !== null) {
            $queryParams['rarity'] = ObjectSerializer::toQueryValue($rarity);
        }
        // query params
        if (is_array($damageTypes)) {
            $damageTypes = ObjectSerializer::serializeCollection($damageTypes, 'multi', true);
        }
        if ($damageTypes !== null) {
            $queryParams['damageTypes'] = ObjectSerializer::toQueryValue($damageTypes);
        }
        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }
        // query params
        if ($rarity2 !== null) {
            $queryParams['rarity'] = ObjectSerializer::toQueryValue($rarity2);
        }
        // query params
        if ($step !== null) {
            $queryParams['step'] = ObjectSerializer::toQueryValue($step);
        }
        // query params
        if ($categories !== null) {
            $queryParams['categories'] = ObjectSerializer::toQueryValue($categories);
        }
        // query params
        if ($weaponPerformance !== null) {
            $queryParams['weaponPerformance'] = ObjectSerializer::toQueryValue($weaponPerformance);
        }
        // query params
        if ($impactEffects !== null) {
            $queryParams['impactEffects'] = ObjectSerializer::toQueryValue($impactEffects);
        }
        // query params
        if ($guardianAttributes !== null) {
            $queryParams['guardianAttributes'] = ObjectSerializer::toQueryValue($guardianAttributes);
        }
        // query params
        if ($lightAbilities !== null) {
            $queryParams['lightAbilities'] = ObjectSerializer::toQueryValue($lightAbilities);
        }
        // query params
        if ($damageTypes2 !== null) {
            $queryParams['damageTypes'] = ObjectSerializer::toQueryValue($damageTypes2);
        }
        // query params
        if ($matchrandomsteps !== null) {
            $queryParams['matchrandomsteps'] = ObjectSerializer::toQueryValue($matchrandomsteps);
        }
        // query params
        if ($definitions2 !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions2);
        }
        // query params
        if ($sourcecat !== null) {
            $queryParams['sourcecat'] = ObjectSerializer::toQueryValue($sourcecat);
        }
        // query params
        if ($sourcehash !== null) {
            $queryParams['sourcehash'] = ObjectSerializer::toQueryValue($sourcehash);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinyExplorerTalentNodeSteps
     *
     * @param  int $page The current page to return. Starts at 1. (optional)
     * @param  int $count The number of results per page. Default is 10. (optional)
     * @param  string $name Filter by name. (optional)
     * @param  \Bungie\D1\Model\DamageType[] $damageTypes Filter by damage type. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $impactEffects impactEffects (optional)
     * @param  string $guardianAttributes guardianAttributes (optional)
     * @param  string $lightAbilities lightAbilities (optional)
     * @param  string $damageTypes2 damageTypes2 (optional)
     * @param  string $definitions2 definitions2 (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20058
     */
    public function getDestinyExplorerTalentNodeSteps($page = null, $count = null, $name = null, $damageTypes = null, $definitions = null, $impactEffects = null, $guardianAttributes = null, $lightAbilities = null, $damageTypes2 = null, $definitions2 = null)
    {
        list($response) = $this->getDestinyExplorerTalentNodeStepsWithHttpInfo($page, $count, $name, $damageTypes, $definitions, $impactEffects, $guardianAttributes, $lightAbilities, $damageTypes2, $definitions2);
        return $response;
    }

    /**
     * Operation getDestinyExplorerTalentNodeStepsWithHttpInfo
     *
     * @param  int $page The current page to return. Starts at 1. (optional)
     * @param  int $count The number of results per page. Default is 10. (optional)
     * @param  string $name Filter by name. (optional)
     * @param  \Bungie\D1\Model\DamageType[] $damageTypes Filter by damage type. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $impactEffects (optional)
     * @param  string $guardianAttributes (optional)
     * @param  string $lightAbilities (optional)
     * @param  string $damageTypes2 (optional)
     * @param  string $definitions2 (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20058, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinyExplorerTalentNodeStepsWithHttpInfo($page = null, $count = null, $name = null, $damageTypes = null, $definitions = null, $impactEffects = null, $guardianAttributes = null, $lightAbilities = null, $damageTypes2 = null, $definitions2 = null)
    {
        $request = $this->getDestinyExplorerTalentNodeStepsRequest($page, $count, $name, $damageTypes, $definitions, $impactEffects, $guardianAttributes, $lightAbilities, $damageTypes2, $definitions2);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20058' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20058', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20058';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20058',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinyExplorerTalentNodeStepsAsync
     *
     * 
     *
     * @param  int $page The current page to return. Starts at 1. (optional)
     * @param  int $count The number of results per page. Default is 10. (optional)
     * @param  string $name Filter by name. (optional)
     * @param  \Bungie\D1\Model\DamageType[] $damageTypes Filter by damage type. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $impactEffects (optional)
     * @param  string $guardianAttributes (optional)
     * @param  string $lightAbilities (optional)
     * @param  string $damageTypes2 (optional)
     * @param  string $definitions2 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyExplorerTalentNodeStepsAsync($page = null, $count = null, $name = null, $damageTypes = null, $definitions = null, $impactEffects = null, $guardianAttributes = null, $lightAbilities = null, $damageTypes2 = null, $definitions2 = null)
    {
        return $this->getDestinyExplorerTalentNodeStepsAsyncWithHttpInfo($page, $count, $name, $damageTypes, $definitions, $impactEffects, $guardianAttributes, $lightAbilities, $damageTypes2, $definitions2)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinyExplorerTalentNodeStepsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $page The current page to return. Starts at 1. (optional)
     * @param  int $count The number of results per page. Default is 10. (optional)
     * @param  string $name Filter by name. (optional)
     * @param  \Bungie\D1\Model\DamageType[] $damageTypes Filter by damage type. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $impactEffects (optional)
     * @param  string $guardianAttributes (optional)
     * @param  string $lightAbilities (optional)
     * @param  string $damageTypes2 (optional)
     * @param  string $definitions2 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyExplorerTalentNodeStepsAsyncWithHttpInfo($page = null, $count = null, $name = null, $damageTypes = null, $definitions = null, $impactEffects = null, $guardianAttributes = null, $lightAbilities = null, $damageTypes2 = null, $definitions2 = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20058';
        $request = $this->getDestinyExplorerTalentNodeStepsRequest($page, $count, $name, $damageTypes, $definitions, $impactEffects, $guardianAttributes, $lightAbilities, $damageTypes2, $definitions2);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinyExplorerTalentNodeSteps'
     *
     * @param  int $page The current page to return. Starts at 1. (optional)
     * @param  int $count The number of results per page. Default is 10. (optional)
     * @param  string $name Filter by name. (optional)
     * @param  \Bungie\D1\Model\DamageType[] $damageTypes Filter by damage type. (optional)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $impactEffects (optional)
     * @param  string $guardianAttributes (optional)
     * @param  string $lightAbilities (optional)
     * @param  string $damageTypes2 (optional)
     * @param  string $definitions2 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinyExplorerTalentNodeStepsRequest($page = null, $count = null, $name = null, $damageTypes = null, $definitions = null, $impactEffects = null, $guardianAttributes = null, $lightAbilities = null, $damageTypes2 = null, $definitions2 = null)
    {

        $resourcePath = '/Destiny/Explorer/TalentNodeSteps/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if (is_array($damageTypes)) {
            $damageTypes = ObjectSerializer::serializeCollection($damageTypes, 'multi', true);
        }
        if ($damageTypes !== null) {
            $queryParams['damageTypes'] = ObjectSerializer::toQueryValue($damageTypes);
        }
        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }
        // query params
        if ($impactEffects !== null) {
            $queryParams['impactEffects'] = ObjectSerializer::toQueryValue($impactEffects);
        }
        // query params
        if ($guardianAttributes !== null) {
            $queryParams['guardianAttributes'] = ObjectSerializer::toQueryValue($guardianAttributes);
        }
        // query params
        if ($lightAbilities !== null) {
            $queryParams['lightAbilities'] = ObjectSerializer::toQueryValue($lightAbilities);
        }
        // query params
        if ($damageTypes2 !== null) {
            $queryParams['damageTypes'] = ObjectSerializer::toQueryValue($damageTypes2);
        }
        // query params
        if ($definitions2 !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions2);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinyLiveTileContentItems
     *
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20030
     */
    public function getDestinyLiveTileContentItems()
    {
        list($response) = $this->getDestinyLiveTileContentItemsWithHttpInfo();
        return $response;
    }

    /**
     * Operation getDestinyLiveTileContentItemsWithHttpInfo
     *
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20030, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinyLiveTileContentItemsWithHttpInfo()
    {
        $request = $this->getDestinyLiveTileContentItemsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20030' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20030', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20030';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20030',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinyLiveTileContentItemsAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyLiveTileContentItemsAsync()
    {
        return $this->getDestinyLiveTileContentItemsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinyLiveTileContentItemsAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyLiveTileContentItemsAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20030';
        $request = $this->getDestinyLiveTileContentItemsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinyLiveTileContentItems'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinyLiveTileContentItemsRequest()
    {

        $resourcePath = '/Destiny/LiveTiles/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinyManifest
     *
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return void
     */
    public function getDestinyManifest()
    {
        $this->getDestinyManifestWithHttpInfo();
    }

    /**
     * Operation getDestinyManifestWithHttpInfo
     *
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinyManifestWithHttpInfo()
    {
        $request = $this->getDestinyManifestRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinyManifestAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyManifestAsync()
    {
        return $this->getDestinyManifestAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinyManifestAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinyManifestAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->getDestinyManifestRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinyManifest'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinyManifestRequest()
    {

        $resourcePath = '/Destiny/Manifest/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDestinySingleDefinition
     *
     * @param  \Bungie\D1\Model\Destiny\DefinitionType $definitionType definitionType (required)
     * @param  int $definitionId definitionId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $version version (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse2003
     */
    public function getDestinySingleDefinition($definitionType, $definitionId, $definitions = null, $version = null)
    {
        list($response) = $this->getDestinySingleDefinitionWithHttpInfo($definitionType, $definitionId, $definitions, $version);
        return $response;
    }

    /**
     * Operation getDestinySingleDefinitionWithHttpInfo
     *
     * @param  \Bungie\D1\Model\Destiny\DefinitionType $definitionType (required)
     * @param  int $definitionId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $version (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDestinySingleDefinitionWithHttpInfo($definitionType, $definitionId, $definitions = null, $version = null)
    {
        $request = $this->getDestinySingleDefinitionRequest($definitionType, $definitionId, $definitions, $version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse2003' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse2003', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse2003';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse2003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDestinySingleDefinitionAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\Destiny\DefinitionType $definitionType (required)
     * @param  int $definitionId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinySingleDefinitionAsync($definitionType, $definitionId, $definitions = null, $version = null)
    {
        return $this->getDestinySingleDefinitionAsyncWithHttpInfo($definitionType, $definitionId, $definitions, $version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDestinySingleDefinitionAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\Destiny\DefinitionType $definitionType (required)
     * @param  int $definitionId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDestinySingleDefinitionAsyncWithHttpInfo($definitionType, $definitionId, $definitions = null, $version = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse2003';
        $request = $this->getDestinySingleDefinitionRequest($definitionType, $definitionId, $definitions, $version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDestinySingleDefinition'
     *
     * @param  \Bungie\D1\Model\Destiny\DefinitionType $definitionType (required)
     * @param  int $definitionId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDestinySingleDefinitionRequest($definitionType, $definitionId, $definitions = null, $version = null)
    {
        // verify the required parameter 'definitionType' is set
        if ($definitionType === null || (is_array($definitionType) && count($definitionType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $definitionType when calling getDestinySingleDefinition'
            );
        }
        // verify the required parameter 'definitionId' is set
        if ($definitionId === null || (is_array($definitionId) && count($definitionId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $definitionId when calling getDestinySingleDefinition'
            );
        }

        $resourcePath = '/Destiny/Manifest/{definitionType}/{definitionId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }
        // query params
        if ($version !== null) {
            $queryParams['version'] = ObjectSerializer::toQueryValue($version);
        }

        // path params
        if ($definitionType !== null) {
            $resourcePath = str_replace(
                '{' . 'definitionType' . '}',
                ObjectSerializer::toPathValue($definitionType),
                $resourcePath
            );
        }
        // path params
        if ($definitionId !== null) {
            $resourcePath = str_replace(
                '{' . 'definitionId' . '}',
                ObjectSerializer::toPathValue($definitionId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExcellenceBadges
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20053
     */
    public function getExcellenceBadges($membershipType, $destinyMembershipId, $definitions = null)
    {
        list($response) = $this->getExcellenceBadgesWithHttpInfo($membershipType, $destinyMembershipId, $definitions);
        return $response;
    }

    /**
     * Operation getExcellenceBadgesWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20053, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExcellenceBadgesWithHttpInfo($membershipType, $destinyMembershipId, $definitions = null)
    {
        $request = $this->getExcellenceBadgesRequest($membershipType, $destinyMembershipId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20053' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20053', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20053';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20053',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getExcellenceBadgesAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExcellenceBadgesAsync($membershipType, $destinyMembershipId, $definitions = null)
    {
        return $this->getExcellenceBadgesAsyncWithHttpInfo($membershipType, $destinyMembershipId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExcellenceBadgesAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExcellenceBadgesAsyncWithHttpInfo($membershipType, $destinyMembershipId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20053';
        $request = $this->getExcellenceBadgesRequest($membershipType, $destinyMembershipId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExcellenceBadges'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getExcellenceBadgesRequest($membershipType, $destinyMembershipId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getExcellenceBadges'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getExcellenceBadges'
            );
        }

        $resourcePath = '/Destiny/Stats/GetExcellenceBadges/{membershipType}/{destinyMembershipId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGrimoireByMembership
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $flavour Indicates flavour stats should be included with player card data. More testing needed. (optional)
     * @param  int $single Return data for a single cardId. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20055
     */
    public function getGrimoireByMembership($membershipType, $destinyMembershipId, $definitions = null, $flavour = null, $single = null)
    {
        list($response) = $this->getGrimoireByMembershipWithHttpInfo($membershipType, $destinyMembershipId, $definitions, $flavour, $single);
        return $response;
    }

    /**
     * Operation getGrimoireByMembershipWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $flavour Indicates flavour stats should be included with player card data. More testing needed. (optional)
     * @param  int $single Return data for a single cardId. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20055, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGrimoireByMembershipWithHttpInfo($membershipType, $destinyMembershipId, $definitions = null, $flavour = null, $single = null)
    {
        $request = $this->getGrimoireByMembershipRequest($membershipType, $destinyMembershipId, $definitions, $flavour, $single);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20055' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20055', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20055';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20055',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGrimoireByMembershipAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $flavour Indicates flavour stats should be included with player card data. More testing needed. (optional)
     * @param  int $single Return data for a single cardId. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGrimoireByMembershipAsync($membershipType, $destinyMembershipId, $definitions = null, $flavour = null, $single = null)
    {
        return $this->getGrimoireByMembershipAsyncWithHttpInfo($membershipType, $destinyMembershipId, $definitions, $flavour, $single)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGrimoireByMembershipAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $flavour Indicates flavour stats should be included with player card data. More testing needed. (optional)
     * @param  int $single Return data for a single cardId. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGrimoireByMembershipAsyncWithHttpInfo($membershipType, $destinyMembershipId, $definitions = null, $flavour = null, $single = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20055';
        $request = $this->getGrimoireByMembershipRequest($membershipType, $destinyMembershipId, $definitions, $flavour, $single);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGrimoireByMembership'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $flavour Indicates flavour stats should be included with player card data. More testing needed. (optional)
     * @param  int $single Return data for a single cardId. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGrimoireByMembershipRequest($membershipType, $destinyMembershipId, $definitions = null, $flavour = null, $single = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getGrimoireByMembership'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getGrimoireByMembership'
            );
        }

        $resourcePath = '/Destiny/Vanguard/Grimoire/{membershipType}/{destinyMembershipId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }
        // query params
        if ($flavour !== null) {
            $queryParams['flavour'] = ObjectSerializer::toQueryValue($flavour);
        }
        // query params
        if ($single !== null) {
            $queryParams['single'] = ObjectSerializer::toQueryValue($single);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGrimoireDefinition
     *
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20056
     */
    public function getGrimoireDefinition()
    {
        list($response) = $this->getGrimoireDefinitionWithHttpInfo();
        return $response;
    }

    /**
     * Operation getGrimoireDefinitionWithHttpInfo
     *
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20056, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGrimoireDefinitionWithHttpInfo()
    {
        $request = $this->getGrimoireDefinitionRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20056' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20056', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20056';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20056',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGrimoireDefinitionAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGrimoireDefinitionAsync()
    {
        return $this->getGrimoireDefinitionAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGrimoireDefinitionAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGrimoireDefinitionAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20056';
        $request = $this->getGrimoireDefinitionRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGrimoireDefinition'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGrimoireDefinitionRequest()
    {

        $resourcePath = '/Destiny/Vanguard/Grimoire/Definition/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoricalStats
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId characterId (required)
     * @param  \Bungie\D1\Model\Destiny\PeriodType $periodType Indicates a specific period type to return. (optional)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  \Bungie\D1\Model\Destiny\StatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated. (optional)
     * @param  string $monthstart First month to return when monthly stats are requested. Use the format YYYY-MM. (optional)
     * @param  string $monthend Last month to return when monthly stats are requested. Use the format YYYY-MM. (optional)
     * @param  string $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  string $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20041
     */
    public function getHistoricalStats($membershipType, $destinyMembershipId, $characterId, $periodType = null, $modes = null, $groups = null, $monthstart = null, $monthend = null, $daystart = null, $dayend = null)
    {
        list($response) = $this->getHistoricalStatsWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $periodType, $modes, $groups, $monthstart, $monthend, $daystart, $dayend);
        return $response;
    }

    /**
     * Operation getHistoricalStatsWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  \Bungie\D1\Model\Destiny\PeriodType $periodType Indicates a specific period type to return. (optional)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  \Bungie\D1\Model\Destiny\StatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated. (optional)
     * @param  string $monthstart First month to return when monthly stats are requested. Use the format YYYY-MM. (optional)
     * @param  string $monthend Last month to return when monthly stats are requested. Use the format YYYY-MM. (optional)
     * @param  string $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  string $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20041, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoricalStatsWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $periodType = null, $modes = null, $groups = null, $monthstart = null, $monthend = null, $daystart = null, $dayend = null)
    {
        $request = $this->getHistoricalStatsRequest($membershipType, $destinyMembershipId, $characterId, $periodType, $modes, $groups, $monthstart, $monthend, $daystart, $dayend);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20041' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20041', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20041';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20041',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoricalStatsAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  \Bungie\D1\Model\Destiny\PeriodType $periodType Indicates a specific period type to return. (optional)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  \Bungie\D1\Model\Destiny\StatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated. (optional)
     * @param  string $monthstart First month to return when monthly stats are requested. Use the format YYYY-MM. (optional)
     * @param  string $monthend Last month to return when monthly stats are requested. Use the format YYYY-MM. (optional)
     * @param  string $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  string $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricalStatsAsync($membershipType, $destinyMembershipId, $characterId, $periodType = null, $modes = null, $groups = null, $monthstart = null, $monthend = null, $daystart = null, $dayend = null)
    {
        return $this->getHistoricalStatsAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $periodType, $modes, $groups, $monthstart, $monthend, $daystart, $dayend)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoricalStatsAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  \Bungie\D1\Model\Destiny\PeriodType $periodType Indicates a specific period type to return. (optional)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  \Bungie\D1\Model\Destiny\StatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated. (optional)
     * @param  string $monthstart First month to return when monthly stats are requested. Use the format YYYY-MM. (optional)
     * @param  string $monthend Last month to return when monthly stats are requested. Use the format YYYY-MM. (optional)
     * @param  string $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  string $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricalStatsAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $periodType = null, $modes = null, $groups = null, $monthstart = null, $monthend = null, $daystart = null, $dayend = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20041';
        $request = $this->getHistoricalStatsRequest($membershipType, $destinyMembershipId, $characterId, $periodType, $modes, $groups, $monthstart, $monthend, $daystart, $dayend);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoricalStats'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  \Bungie\D1\Model\Destiny\PeriodType $periodType Indicates a specific period type to return. (optional)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  \Bungie\D1\Model\Destiny\StatsGroupType[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated. (optional)
     * @param  string $monthstart First month to return when monthly stats are requested. Use the format YYYY-MM. (optional)
     * @param  string $monthend Last month to return when monthly stats are requested. Use the format YYYY-MM. (optional)
     * @param  string $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     * @param  string $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoricalStatsRequest($membershipType, $destinyMembershipId, $characterId, $periodType = null, $modes = null, $groups = null, $monthstart = null, $monthend = null, $daystart = null, $dayend = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getHistoricalStats'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getHistoricalStats'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getHistoricalStats'
            );
        }

        $resourcePath = '/Destiny/Stats/{membershipType}/{destinyMembershipId}/{characterId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($periodType !== null) {
            $queryParams['periodType'] = ObjectSerializer::toQueryValue($periodType);
        }
        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, 'multi', true);
        }
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if (is_array($groups)) {
            $groups = ObjectSerializer::serializeCollection($groups, 'multi', true);
        }
        if ($groups !== null) {
            $queryParams['groups'] = ObjectSerializer::toQueryValue($groups);
        }
        // query params
        if ($monthstart !== null) {
            $queryParams['monthstart'] = ObjectSerializer::toQueryValue($monthstart);
        }
        // query params
        if ($monthend !== null) {
            $queryParams['monthend'] = ObjectSerializer::toQueryValue($monthend);
        }
        // query params
        if ($daystart !== null) {
            $queryParams['daystart'] = ObjectSerializer::toQueryValue($daystart);
        }
        // query params
        if ($dayend !== null) {
            $queryParams['dayend'] = ObjectSerializer::toQueryValue($dayend);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoricalStatsDefinition
     *
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20040
     */
    public function getHistoricalStatsDefinition()
    {
        list($response) = $this->getHistoricalStatsDefinitionWithHttpInfo();
        return $response;
    }

    /**
     * Operation getHistoricalStatsDefinitionWithHttpInfo
     *
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20040, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoricalStatsDefinitionWithHttpInfo()
    {
        $request = $this->getHistoricalStatsDefinitionRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20040' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20040', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20040';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20040',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoricalStatsDefinitionAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricalStatsDefinitionAsync()
    {
        return $this->getHistoricalStatsDefinitionAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoricalStatsDefinitionAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricalStatsDefinitionAsyncWithHttpInfo()
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20040';
        $request = $this->getHistoricalStatsDefinitionRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoricalStatsDefinition'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoricalStatsDefinitionRequest()
    {

        $resourcePath = '/Destiny/Stats/Definition/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoricalStatsForAccount
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $groups groups (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20042
     */
    public function getHistoricalStatsForAccount($membershipType, $destinyMembershipId, $groups = null)
    {
        list($response) = $this->getHistoricalStatsForAccountWithHttpInfo($membershipType, $destinyMembershipId, $groups);
        return $response;
    }

    /**
     * Operation getHistoricalStatsForAccountWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $groups (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20042, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoricalStatsForAccountWithHttpInfo($membershipType, $destinyMembershipId, $groups = null)
    {
        $request = $this->getHistoricalStatsForAccountRequest($membershipType, $destinyMembershipId, $groups);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20042' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20042', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20042';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20042',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoricalStatsForAccountAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $groups (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricalStatsForAccountAsync($membershipType, $destinyMembershipId, $groups = null)
    {
        return $this->getHistoricalStatsForAccountAsyncWithHttpInfo($membershipType, $destinyMembershipId, $groups)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoricalStatsForAccountAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $groups (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricalStatsForAccountAsyncWithHttpInfo($membershipType, $destinyMembershipId, $groups = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20042';
        $request = $this->getHistoricalStatsForAccountRequest($membershipType, $destinyMembershipId, $groups);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoricalStatsForAccount'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $groups (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoricalStatsForAccountRequest($membershipType, $destinyMembershipId, $groups = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getHistoricalStatsForAccount'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getHistoricalStatsForAccount'
            );
        }

        $resourcePath = '/Destiny/Stats/Account/{membershipType}/{destinyMembershipId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($groups !== null) {
            $queryParams['groups'] = ObjectSerializer::toQueryValue($groups);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getItemDetail
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId characterId (required)
     * @param  string $itemInstanceId itemInstanceId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20015
     */
    public function getItemDetail($membershipType, $destinyMembershipId, $characterId, $itemInstanceId, $definitions = null)
    {
        list($response) = $this->getItemDetailWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $itemInstanceId, $definitions);
        return $response;
    }

    /**
     * Operation getItemDetailWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  string $itemInstanceId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20015, HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemDetailWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $itemInstanceId, $definitions = null)
    {
        $request = $this->getItemDetailRequest($membershipType, $destinyMembershipId, $characterId, $itemInstanceId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20015' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20015', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20015';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20015',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getItemDetailAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  string $itemInstanceId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemDetailAsync($membershipType, $destinyMembershipId, $characterId, $itemInstanceId, $definitions = null)
    {
        return $this->getItemDetailAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $itemInstanceId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getItemDetailAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  string $itemInstanceId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemDetailAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $itemInstanceId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20015';
        $request = $this->getItemDetailRequest($membershipType, $destinyMembershipId, $characterId, $itemInstanceId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getItemDetail'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  string $itemInstanceId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getItemDetailRequest($membershipType, $destinyMembershipId, $characterId, $itemInstanceId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getItemDetail'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getItemDetail'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getItemDetail'
            );
        }
        // verify the required parameter 'itemInstanceId' is set
        if ($itemInstanceId === null || (is_array($itemInstanceId) && count($itemInstanceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $itemInstanceId when calling getItemDetail'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Inventory/{itemInstanceId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($itemInstanceId !== null) {
            $resourcePath = str_replace(
                '{' . 'itemInstanceId' . '}',
                ObjectSerializer::toPathValue($itemInstanceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getItemReferenceDetail
     *
     * @param  string $param1 param1 (required)
     * @param  string $param2 param2 (required)
     * @param  string $param3 param3 (required)
     * @param  string $param4 param4 (required)
     * @param  string $definitions definitions (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse2005
     */
    public function getItemReferenceDetail($param1, $param2, $param3, $param4, $definitions = null)
    {
        list($response) = $this->getItemReferenceDetailWithHttpInfo($param1, $param2, $param3, $param4, $definitions);
        return $response;
    }

    /**
     * Operation getItemReferenceDetailWithHttpInfo
     *
     * @param  string $param1 (required)
     * @param  string $param2 (required)
     * @param  string $param3 (required)
     * @param  string $param4 (required)
     * @param  string $definitions (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse2005, HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemReferenceDetailWithHttpInfo($param1, $param2, $param3, $param4, $definitions = null)
    {
        $request = $this->getItemReferenceDetailRequest($param1, $param2, $param3, $param4, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse2005' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse2005', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse2005';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse2005',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getItemReferenceDetailAsync
     *
     * 
     *
     * @param  string $param1 (required)
     * @param  string $param2 (required)
     * @param  string $param3 (required)
     * @param  string $param4 (required)
     * @param  string $definitions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemReferenceDetailAsync($param1, $param2, $param3, $param4, $definitions = null)
    {
        return $this->getItemReferenceDetailAsyncWithHttpInfo($param1, $param2, $param3, $param4, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getItemReferenceDetailAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $param1 (required)
     * @param  string $param2 (required)
     * @param  string $param3 (required)
     * @param  string $param4 (required)
     * @param  string $definitions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemReferenceDetailAsyncWithHttpInfo($param1, $param2, $param3, $param4, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse2005';
        $request = $this->getItemReferenceDetailRequest($param1, $param2, $param3, $param4, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getItemReferenceDetail'
     *
     * @param  string $param1 (required)
     * @param  string $param2 (required)
     * @param  string $param3 (required)
     * @param  string $param4 (required)
     * @param  string $definitions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getItemReferenceDetailRequest($param1, $param2, $param3, $param4, $definitions = null)
    {
        // verify the required parameter 'param1' is set
        if ($param1 === null || (is_array($param1) && count($param1) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $param1 when calling getItemReferenceDetail'
            );
        }
        // verify the required parameter 'param2' is set
        if ($param2 === null || (is_array($param2) && count($param2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $param2 when calling getItemReferenceDetail'
            );
        }
        // verify the required parameter 'param3' is set
        if ($param3 === null || (is_array($param3) && count($param3) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $param3 when calling getItemReferenceDetail'
            );
        }
        // verify the required parameter 'param4' is set
        if ($param4 === null || (is_array($param4) && count($param4) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $param4 when calling getItemReferenceDetail'
            );
        }

        $resourcePath = '/Destiny/{param1}/Account/{param2}/Character/{param3}/ItemReference/{param4}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($param1 !== null) {
            $resourcePath = str_replace(
                '{' . 'param1' . '}',
                ObjectSerializer::toPathValue($param1),
                $resourcePath
            );
        }
        // path params
        if ($param2 !== null) {
            $resourcePath = str_replace(
                '{' . 'param2' . '}',
                ObjectSerializer::toPathValue($param2),
                $resourcePath
            );
        }
        // path params
        if ($param3 !== null) {
            $resourcePath = str_replace(
                '{' . 'param3' . '}',
                ObjectSerializer::toPathValue($param3),
                $resourcePath
            );
        }
        // path params
        if ($param4 !== null) {
            $resourcePath = str_replace(
                '{' . 'param4' . '}',
                ObjectSerializer::toPathValue($param4),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLeaderboards
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $statid statid (optional)
     * @param  string $maxtop maxtop (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20045
     */
    public function getLeaderboards($membershipType, $destinyMembershipId, $modes = null, $statid = null, $maxtop = null)
    {
        list($response) = $this->getLeaderboardsWithHttpInfo($membershipType, $destinyMembershipId, $modes, $statid, $maxtop);
        return $response;
    }

    /**
     * Operation getLeaderboardsWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $statid (optional)
     * @param  string $maxtop (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20045, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLeaderboardsWithHttpInfo($membershipType, $destinyMembershipId, $modes = null, $statid = null, $maxtop = null)
    {
        $request = $this->getLeaderboardsRequest($membershipType, $destinyMembershipId, $modes, $statid, $maxtop);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20045' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20045', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20045';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20045',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLeaderboardsAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $statid (optional)
     * @param  string $maxtop (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLeaderboardsAsync($membershipType, $destinyMembershipId, $modes = null, $statid = null, $maxtop = null)
    {
        return $this->getLeaderboardsAsyncWithHttpInfo($membershipType, $destinyMembershipId, $modes, $statid, $maxtop)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLeaderboardsAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $statid (optional)
     * @param  string $maxtop (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLeaderboardsAsyncWithHttpInfo($membershipType, $destinyMembershipId, $modes = null, $statid = null, $maxtop = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20045';
        $request = $this->getLeaderboardsRequest($membershipType, $destinyMembershipId, $modes, $statid, $maxtop);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLeaderboards'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $statid (optional)
     * @param  string $maxtop (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLeaderboardsRequest($membershipType, $destinyMembershipId, $modes = null, $statid = null, $maxtop = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getLeaderboards'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getLeaderboards'
            );
        }

        $resourcePath = '/Destiny/Stats/Leaderboards/{membershipType}/{destinyMembershipId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, 'multi', true);
        }
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($statid !== null) {
            $queryParams['statid'] = ObjectSerializer::toQueryValue($statid);
        }
        // query params
        if ($maxtop !== null) {
            $queryParams['maxtop'] = ObjectSerializer::toQueryValue($maxtop);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLeaderboardsForCharacter
     *
     * @param  string $param1 param1 (required)
     * @param  string $param2 param2 (required)
     * @param  string $param3 param3 (required)
     * @param  string $modes modes (optional)
     * @param  string $statid statid (optional)
     * @param  string $maxtop maxtop (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20048
     */
    public function getLeaderboardsForCharacter($param1, $param2, $param3, $modes = null, $statid = null, $maxtop = null)
    {
        list($response) = $this->getLeaderboardsForCharacterWithHttpInfo($param1, $param2, $param3, $modes, $statid, $maxtop);
        return $response;
    }

    /**
     * Operation getLeaderboardsForCharacterWithHttpInfo
     *
     * @param  string $param1 (required)
     * @param  string $param2 (required)
     * @param  string $param3 (required)
     * @param  string $modes (optional)
     * @param  string $statid (optional)
     * @param  string $maxtop (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20048, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLeaderboardsForCharacterWithHttpInfo($param1, $param2, $param3, $modes = null, $statid = null, $maxtop = null)
    {
        $request = $this->getLeaderboardsForCharacterRequest($param1, $param2, $param3, $modes, $statid, $maxtop);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20048' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20048', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20048';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20048',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLeaderboardsForCharacterAsync
     *
     * 
     *
     * @param  string $param1 (required)
     * @param  string $param2 (required)
     * @param  string $param3 (required)
     * @param  string $modes (optional)
     * @param  string $statid (optional)
     * @param  string $maxtop (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLeaderboardsForCharacterAsync($param1, $param2, $param3, $modes = null, $statid = null, $maxtop = null)
    {
        return $this->getLeaderboardsForCharacterAsyncWithHttpInfo($param1, $param2, $param3, $modes, $statid, $maxtop)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLeaderboardsForCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $param1 (required)
     * @param  string $param2 (required)
     * @param  string $param3 (required)
     * @param  string $modes (optional)
     * @param  string $statid (optional)
     * @param  string $maxtop (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLeaderboardsForCharacterAsyncWithHttpInfo($param1, $param2, $param3, $modes = null, $statid = null, $maxtop = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20048';
        $request = $this->getLeaderboardsForCharacterRequest($param1, $param2, $param3, $modes, $statid, $maxtop);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLeaderboardsForCharacter'
     *
     * @param  string $param1 (required)
     * @param  string $param2 (required)
     * @param  string $param3 (required)
     * @param  string $modes (optional)
     * @param  string $statid (optional)
     * @param  string $maxtop (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLeaderboardsForCharacterRequest($param1, $param2, $param3, $modes = null, $statid = null, $maxtop = null)
    {
        // verify the required parameter 'param1' is set
        if ($param1 === null || (is_array($param1) && count($param1) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $param1 when calling getLeaderboardsForCharacter'
            );
        }
        // verify the required parameter 'param2' is set
        if ($param2 === null || (is_array($param2) && count($param2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $param2 when calling getLeaderboardsForCharacter'
            );
        }
        // verify the required parameter 'param3' is set
        if ($param3 === null || (is_array($param3) && count($param3) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $param3 when calling getLeaderboardsForCharacter'
            );
        }

        $resourcePath = '/Destiny/Stats/Leaderboards/{param1}/{param2}/{param3}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($statid !== null) {
            $queryParams['statid'] = ObjectSerializer::toQueryValue($statid);
        }
        // query params
        if ($maxtop !== null) {
            $queryParams['maxtop'] = ObjectSerializer::toQueryValue($maxtop);
        }

        // path params
        if ($param1 !== null) {
            $resourcePath = str_replace(
                '{' . 'param1' . '}',
                ObjectSerializer::toPathValue($param1),
                $resourcePath
            );
        }
        // path params
        if ($param2 !== null) {
            $resourcePath = str_replace(
                '{' . 'param2' . '}',
                ObjectSerializer::toPathValue($param2),
                $resourcePath
            );
        }
        // path params
        if ($param3 !== null) {
            $resourcePath = str_replace(
                '{' . 'param3' . '}',
                ObjectSerializer::toPathValue($param3),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLeaderboardsForPsn
     *
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $code code (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20047
     */
    public function getLeaderboardsForPsn($modes = null, $code = null)
    {
        list($response) = $this->getLeaderboardsForPsnWithHttpInfo($modes, $code);
        return $response;
    }

    /**
     * Operation getLeaderboardsForPsnWithHttpInfo
     *
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $code (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20047, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLeaderboardsForPsnWithHttpInfo($modes = null, $code = null)
    {
        $request = $this->getLeaderboardsForPsnRequest($modes, $code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20047' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20047', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20047';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20047',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLeaderboardsForPsnAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLeaderboardsForPsnAsync($modes = null, $code = null)
    {
        return $this->getLeaderboardsForPsnAsyncWithHttpInfo($modes, $code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLeaderboardsForPsnAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLeaderboardsForPsnAsyncWithHttpInfo($modes = null, $code = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20047';
        $request = $this->getLeaderboardsForPsnRequest($modes, $code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLeaderboardsForPsn'
     *
     * @param  \Bungie\D1\Model\Destiny\ActivityModeType[] $modes Game modes to return. Comma separated. (optional)
     * @param  string $code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLeaderboardsForPsnRequest($modes = null, $code = null)
    {

        $resourcePath = '/Destiny/Stats/LeaderboardsForPsn/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, 'multi', true);
        }
        if ($modes !== null) {
            $queryParams['modes'] = ObjectSerializer::toQueryValue($modes);
        }
        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMembershipIdByDisplayName
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $displayName A valid PSN Id or Gamertag display name. (required)
     * @param  bool $ignorecase Default is false when not specified. True to cause a caseless search to be used. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20052
     */
    public function getMembershipIdByDisplayName($membershipType, $displayName, $ignorecase = null)
    {
        list($response) = $this->getMembershipIdByDisplayNameWithHttpInfo($membershipType, $displayName, $ignorecase);
        return $response;
    }

    /**
     * Operation getMembershipIdByDisplayNameWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $displayName A valid PSN Id or Gamertag display name. (required)
     * @param  bool $ignorecase Default is false when not specified. True to cause a caseless search to be used. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20052, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMembershipIdByDisplayNameWithHttpInfo($membershipType, $displayName, $ignorecase = null)
    {
        $request = $this->getMembershipIdByDisplayNameRequest($membershipType, $displayName, $ignorecase);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20052' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20052', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20052';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20052',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMembershipIdByDisplayNameAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $displayName A valid PSN Id or Gamertag display name. (required)
     * @param  bool $ignorecase Default is false when not specified. True to cause a caseless search to be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMembershipIdByDisplayNameAsync($membershipType, $displayName, $ignorecase = null)
    {
        return $this->getMembershipIdByDisplayNameAsyncWithHttpInfo($membershipType, $displayName, $ignorecase)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMembershipIdByDisplayNameAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $displayName A valid PSN Id or Gamertag display name. (required)
     * @param  bool $ignorecase Default is false when not specified. True to cause a caseless search to be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMembershipIdByDisplayNameAsyncWithHttpInfo($membershipType, $displayName, $ignorecase = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20052';
        $request = $this->getMembershipIdByDisplayNameRequest($membershipType, $displayName, $ignorecase);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMembershipIdByDisplayName'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $displayName A valid PSN Id or Gamertag display name. (required)
     * @param  bool $ignorecase Default is false when not specified. True to cause a caseless search to be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMembershipIdByDisplayNameRequest($membershipType, $displayName, $ignorecase = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getMembershipIdByDisplayName'
            );
        }
        // verify the required parameter 'displayName' is set
        if ($displayName === null || (is_array($displayName) && count($displayName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $displayName when calling getMembershipIdByDisplayName'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Stats/GetMembershipIdByDisplayName/{displayName}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ignorecase !== null) {
            $queryParams['ignorecase'] = ObjectSerializer::toQueryValue($ignorecase);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($displayName !== null) {
            $resourcePath = str_replace(
                '{' . 'displayName' . '}',
                ObjectSerializer::toPathValue($displayName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyGrimoire
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $flavour Indicates flavour stats should be included with player card data. More testing needed. (optional)
     * @param  int $single Return data for a single cardId. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20054
     */
    public function getMyGrimoire($membershipType, $definitions = null, $flavour = null, $single = null)
    {
        list($response) = $this->getMyGrimoireWithHttpInfo($membershipType, $definitions, $flavour, $single);
        return $response;
    }

    /**
     * Operation getMyGrimoireWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $flavour Indicates flavour stats should be included with player card data. More testing needed. (optional)
     * @param  int $single Return data for a single cardId. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20054, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyGrimoireWithHttpInfo($membershipType, $definitions = null, $flavour = null, $single = null)
    {
        $request = $this->getMyGrimoireRequest($membershipType, $definitions, $flavour, $single);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20054' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20054', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20054';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20054',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMyGrimoireAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $flavour Indicates flavour stats should be included with player card data. More testing needed. (optional)
     * @param  int $single Return data for a single cardId. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyGrimoireAsync($membershipType, $definitions = null, $flavour = null, $single = null)
    {
        return $this->getMyGrimoireAsyncWithHttpInfo($membershipType, $definitions, $flavour, $single)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyGrimoireAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $flavour Indicates flavour stats should be included with player card data. More testing needed. (optional)
     * @param  int $single Return data for a single cardId. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyGrimoireAsyncWithHttpInfo($membershipType, $definitions = null, $flavour = null, $single = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20054';
        $request = $this->getMyGrimoireRequest($membershipType, $definitions, $flavour, $single);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyGrimoire'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  string $flavour Indicates flavour stats should be included with player card data. More testing needed. (optional)
     * @param  int $single Return data for a single cardId. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMyGrimoireRequest($membershipType, $definitions = null, $flavour = null, $single = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getMyGrimoire'
            );
        }

        $resourcePath = '/Destiny/Vanguard/Grimoire/{membershipType}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }
        // query params
        if ($flavour !== null) {
            $queryParams['flavour'] = ObjectSerializer::toQueryValue($flavour);
        }
        // query params
        if ($single !== null) {
            $queryParams['single'] = ObjectSerializer::toQueryValue($single);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPostGameCarnageReport
     *
     * @param  int $activityInstanceId A valid activityInstanceId. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20049
     */
    public function getPostGameCarnageReport($activityInstanceId, $definitions = null)
    {
        list($response) = $this->getPostGameCarnageReportWithHttpInfo($activityInstanceId, $definitions);
        return $response;
    }

    /**
     * Operation getPostGameCarnageReportWithHttpInfo
     *
     * @param  int $activityInstanceId A valid activityInstanceId. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20049, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPostGameCarnageReportWithHttpInfo($activityInstanceId, $definitions = null)
    {
        $request = $this->getPostGameCarnageReportRequest($activityInstanceId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20049' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20049', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20049';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20049',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPostGameCarnageReportAsync
     *
     * 
     *
     * @param  int $activityInstanceId A valid activityInstanceId. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPostGameCarnageReportAsync($activityInstanceId, $definitions = null)
    {
        return $this->getPostGameCarnageReportAsyncWithHttpInfo($activityInstanceId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPostGameCarnageReportAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $activityInstanceId A valid activityInstanceId. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPostGameCarnageReportAsyncWithHttpInfo($activityInstanceId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20049';
        $request = $this->getPostGameCarnageReportRequest($activityInstanceId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPostGameCarnageReport'
     *
     * @param  int $activityInstanceId A valid activityInstanceId. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPostGameCarnageReportRequest($activityInstanceId, $definitions = null)
    {
        // verify the required parameter 'activityInstanceId' is set
        if ($activityInstanceId === null || (is_array($activityInstanceId) && count($activityInstanceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $activityInstanceId when calling getPostGameCarnageReport'
            );
        }

        $resourcePath = '/Destiny/Stats/PostGameCarnageReport/{activityInstanceId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($activityInstanceId !== null) {
            $resourcePath = str_replace(
                '{' . 'activityInstanceId' . '}',
                ObjectSerializer::toPathValue($activityInstanceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublicAdvisors
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20024
     */
    public function getPublicAdvisors($definitions = null)
    {
        list($response) = $this->getPublicAdvisorsWithHttpInfo($definitions);
        return $response;
    }

    /**
     * Operation getPublicAdvisorsWithHttpInfo
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20024, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublicAdvisorsWithHttpInfo($definitions = null)
    {
        $request = $this->getPublicAdvisorsRequest($definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20024' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20024', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20024';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20024',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPublicAdvisorsAsync
     *
     * 
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicAdvisorsAsync($definitions = null)
    {
        return $this->getPublicAdvisorsAsyncWithHttpInfo($definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublicAdvisorsAsyncWithHttpInfo
     *
     * 
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicAdvisorsAsyncWithHttpInfo($definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20024';
        $request = $this->getPublicAdvisorsRequest($definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublicAdvisors'
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPublicAdvisorsRequest($definitions = null)
    {

        $resourcePath = '/Destiny/Advisors/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublicAdvisorsV2
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse200
     */
    public function getPublicAdvisorsV2($definitions = null)
    {
        list($response) = $this->getPublicAdvisorsV2WithHttpInfo($definitions);
        return $response;
    }

    /**
     * Operation getPublicAdvisorsV2WithHttpInfo
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse200, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublicAdvisorsV2WithHttpInfo($definitions = null)
    {
        $request = $this->getPublicAdvisorsV2Request($definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse200' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse200', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse200';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPublicAdvisorsV2Async
     *
     * 
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicAdvisorsV2Async($definitions = null)
    {
        return $this->getPublicAdvisorsV2AsyncWithHttpInfo($definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublicAdvisorsV2AsyncWithHttpInfo
     *
     * 
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicAdvisorsV2AsyncWithHttpInfo($definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse200';
        $request = $this->getPublicAdvisorsV2Request($definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublicAdvisorsV2'
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPublicAdvisorsV2Request($definitions = null)
    {

        $resourcePath = '/Destiny/Advisors/V2/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublicVendor
     *
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20026
     */
    public function getPublicVendor($vendorHash, $definitions = null)
    {
        list($response) = $this->getPublicVendorWithHttpInfo($vendorHash, $definitions);
        return $response;
    }

    /**
     * Operation getPublicVendorWithHttpInfo
     *
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20026, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublicVendorWithHttpInfo($vendorHash, $definitions = null)
    {
        $request = $this->getPublicVendorRequest($vendorHash, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20026' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20026', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20026';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20026',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPublicVendorAsync
     *
     * 
     *
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicVendorAsync($vendorHash, $definitions = null)
    {
        return $this->getPublicVendorAsyncWithHttpInfo($vendorHash, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublicVendorAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicVendorAsyncWithHttpInfo($vendorHash, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20026';
        $request = $this->getPublicVendorRequest($vendorHash, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublicVendor'
     *
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPublicVendorRequest($vendorHash, $definitions = null)
    {
        // verify the required parameter 'vendorHash' is set
        if ($vendorHash === null || (is_array($vendorHash) && count($vendorHash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorHash when calling getPublicVendor'
            );
        }

        $resourcePath = '/Destiny/Vendors/{vendorHash}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($vendorHash !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorHash' . '}',
                ObjectSerializer::toPathValue($vendorHash),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublicVendorWithMetadata
     *
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20032
     */
    public function getPublicVendorWithMetadata($vendorHash, $definitions = null)
    {
        list($response) = $this->getPublicVendorWithMetadataWithHttpInfo($vendorHash, $definitions);
        return $response;
    }

    /**
     * Operation getPublicVendorWithMetadataWithHttpInfo
     *
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20032, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublicVendorWithMetadataWithHttpInfo($vendorHash, $definitions = null)
    {
        $request = $this->getPublicVendorWithMetadataRequest($vendorHash, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20032' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20032', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20032';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20032',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPublicVendorWithMetadataAsync
     *
     * 
     *
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicVendorWithMetadataAsync($vendorHash, $definitions = null)
    {
        return $this->getPublicVendorWithMetadataAsyncWithHttpInfo($vendorHash, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublicVendorWithMetadataAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicVendorWithMetadataAsyncWithHttpInfo($vendorHash, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20032';
        $request = $this->getPublicVendorWithMetadataRequest($vendorHash, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublicVendorWithMetadata'
     *
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPublicVendorWithMetadataRequest($vendorHash, $definitions = null)
    {
        // verify the required parameter 'vendorHash' is set
        if ($vendorHash === null || (is_array($vendorHash) && count($vendorHash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorHash when calling getPublicVendorWithMetadata'
            );
        }

        $resourcePath = '/Destiny/Vendors/{vendorHash}/Metadata/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($vendorHash !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorHash' . '}',
                ObjectSerializer::toPathValue($vendorHash),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublicXurVendor
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20025
     */
    public function getPublicXurVendor($definitions = null)
    {
        list($response) = $this->getPublicXurVendorWithHttpInfo($definitions);
        return $response;
    }

    /**
     * Operation getPublicXurVendorWithHttpInfo
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20025, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublicXurVendorWithHttpInfo($definitions = null)
    {
        $request = $this->getPublicXurVendorRequest($definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20025' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20025', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20025';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20025',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPublicXurVendorAsync
     *
     * 
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicXurVendorAsync($definitions = null)
    {
        return $this->getPublicXurVendorAsyncWithHttpInfo($definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublicXurVendorAsyncWithHttpInfo
     *
     * 
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicXurVendorAsyncWithHttpInfo($definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20025';
        $request = $this->getPublicXurVendorRequest($definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublicXurVendor'
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPublicXurVendorRequest($definitions = null)
    {

        $resourcePath = '/Destiny/Advisors/Xur/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordBookCompletionStatus
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $recordBookHash recordBookHash (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20019
     */
    public function getRecordBookCompletionStatus($membershipType, $recordBookHash, $definitions = null)
    {
        list($response) = $this->getRecordBookCompletionStatusWithHttpInfo($membershipType, $recordBookHash, $definitions);
        return $response;
    }

    /**
     * Operation getRecordBookCompletionStatusWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $recordBookHash (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordBookCompletionStatusWithHttpInfo($membershipType, $recordBookHash, $definitions = null)
    {
        $request = $this->getRecordBookCompletionStatusRequest($membershipType, $recordBookHash, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20019';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecordBookCompletionStatusAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $recordBookHash (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordBookCompletionStatusAsync($membershipType, $recordBookHash, $definitions = null)
    {
        return $this->getRecordBookCompletionStatusAsyncWithHttpInfo($membershipType, $recordBookHash, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordBookCompletionStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $recordBookHash (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordBookCompletionStatusAsyncWithHttpInfo($membershipType, $recordBookHash, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20019';
        $request = $this->getRecordBookCompletionStatusRequest($membershipType, $recordBookHash, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordBookCompletionStatus'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $recordBookHash (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecordBookCompletionStatusRequest($membershipType, $recordBookHash, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getRecordBookCompletionStatus'
            );
        }
        // verify the required parameter 'recordBookHash' is set
        if ($recordBookHash === null || (is_array($recordBookHash) && count($recordBookHash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recordBookHash when calling getRecordBookCompletionStatus'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/MyAccount/RecordBooks/{recordBookHash}/Completion/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($recordBookHash !== null) {
            $resourcePath = str_replace(
                '{' . 'recordBookHash' . '}',
                ObjectSerializer::toPathValue($recordBookHash),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSpecialEventAdvisors
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20029
     */
    public function getSpecialEventAdvisors($definitions = null)
    {
        list($response) = $this->getSpecialEventAdvisorsWithHttpInfo($definitions);
        return $response;
    }

    /**
     * Operation getSpecialEventAdvisorsWithHttpInfo
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20029, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSpecialEventAdvisorsWithHttpInfo($definitions = null)
    {
        $request = $this->getSpecialEventAdvisorsRequest($definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20029' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20029', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20029';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20029',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSpecialEventAdvisorsAsync
     *
     * 
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpecialEventAdvisorsAsync($definitions = null)
    {
        return $this->getSpecialEventAdvisorsAsyncWithHttpInfo($definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSpecialEventAdvisorsAsyncWithHttpInfo
     *
     * 
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpecialEventAdvisorsAsyncWithHttpInfo($definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20029';
        $request = $this->getSpecialEventAdvisorsRequest($definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSpecialEventAdvisors'
     *
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSpecialEventAdvisorsRequest($definitions = null)
    {

        $resourcePath = '/Destiny/Events/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTriumphs
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20018
     */
    public function getTriumphs($membershipType, $destinyMembershipId, $definitions = null)
    {
        list($response) = $this->getTriumphsWithHttpInfo($membershipType, $destinyMembershipId, $definitions);
        return $response;
    }

    /**
     * Operation getTriumphsWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20018, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTriumphsWithHttpInfo($membershipType, $destinyMembershipId, $definitions = null)
    {
        $request = $this->getTriumphsRequest($membershipType, $destinyMembershipId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20018' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20018', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20018';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20018',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTriumphsAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTriumphsAsync($membershipType, $destinyMembershipId, $definitions = null)
    {
        return $this->getTriumphsAsyncWithHttpInfo($membershipType, $destinyMembershipId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTriumphsAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTriumphsAsyncWithHttpInfo($membershipType, $destinyMembershipId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20018';
        $request = $this->getTriumphsRequest($membershipType, $destinyMembershipId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTriumphs'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTriumphsRequest($membershipType, $destinyMembershipId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getTriumphs'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getTriumphs'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/Account/{destinyMembershipId}/Triumphs/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUniqueWeaponHistory
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20044
     */
    public function getUniqueWeaponHistory($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        list($response) = $this->getUniqueWeaponHistoryWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions);
        return $response;
    }

    /**
     * Operation getUniqueWeaponHistoryWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20044, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUniqueWeaponHistoryWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $request = $this->getUniqueWeaponHistoryRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20044' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20044', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20044';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUniqueWeaponHistoryAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUniqueWeaponHistoryAsync($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        return $this->getUniqueWeaponHistoryAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUniqueWeaponHistoryAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUniqueWeaponHistoryAsyncWithHttpInfo($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20044';
        $request = $this->getUniqueWeaponHistoryRequest($membershipType, $destinyMembershipId, $characterId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUniqueWeaponHistory'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  int $destinyMembershipId Destiny membership ID. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUniqueWeaponHistoryRequest($membershipType, $destinyMembershipId, $characterId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getUniqueWeaponHistory'
            );
        }
        // verify the required parameter 'destinyMembershipId' is set
        if ($destinyMembershipId === null || (is_array($destinyMembershipId) && count($destinyMembershipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destinyMembershipId when calling getUniqueWeaponHistory'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getUniqueWeaponHistory'
            );
        }

        $resourcePath = '/Destiny/Stats/UniqueWeapons/{membershipType}/{destinyMembershipId}/{characterId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($destinyMembershipId !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destinyMembershipId),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVault
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  int $accountId Destiny membership ID. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse2009
     */
    public function getVault($membershipType, $definitions = null, $accountId = null)
    {
        list($response) = $this->getVaultWithHttpInfo($membershipType, $definitions, $accountId);
        return $response;
    }

    /**
     * Operation getVaultWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  int $accountId Destiny membership ID. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse2009, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVaultWithHttpInfo($membershipType, $definitions = null, $accountId = null)
    {
        $request = $this->getVaultRequest($membershipType, $definitions, $accountId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse2009' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse2009', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse2009';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse2009',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVaultAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  int $accountId Destiny membership ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVaultAsync($membershipType, $definitions = null, $accountId = null)
    {
        return $this->getVaultAsyncWithHttpInfo($membershipType, $definitions, $accountId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVaultAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  int $accountId Destiny membership ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVaultAsyncWithHttpInfo($membershipType, $definitions = null, $accountId = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse2009';
        $request = $this->getVaultRequest($membershipType, $definitions, $accountId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVault'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  int $accountId Destiny membership ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVaultRequest($membershipType, $definitions = null, $accountId = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getVault'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/MyAccount/Vault/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }
        // query params
        if ($accountId !== null) {
            $queryParams['accountId'] = ObjectSerializer::toQueryValue($accountId);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVaultSummary
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  int $accountId Destiny membership ID. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20010
     */
    public function getVaultSummary($membershipType, $definitions = null, $accountId = null)
    {
        list($response) = $this->getVaultSummaryWithHttpInfo($membershipType, $definitions, $accountId);
        return $response;
    }

    /**
     * Operation getVaultSummaryWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  int $accountId Destiny membership ID. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20010, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVaultSummaryWithHttpInfo($membershipType, $definitions = null, $accountId = null)
    {
        $request = $this->getVaultSummaryRequest($membershipType, $definitions, $accountId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20010' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20010', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20010';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20010',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVaultSummaryAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  int $accountId Destiny membership ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVaultSummaryAsync($membershipType, $definitions = null, $accountId = null)
    {
        return $this->getVaultSummaryAsyncWithHttpInfo($membershipType, $definitions, $accountId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVaultSummaryAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  int $accountId Destiny membership ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVaultSummaryAsyncWithHttpInfo($membershipType, $definitions = null, $accountId = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20010';
        $request = $this->getVaultSummaryRequest($membershipType, $definitions, $accountId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVaultSummary'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     * @param  int $accountId Destiny membership ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVaultSummaryRequest($membershipType, $definitions = null, $accountId = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getVaultSummary'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/MyAccount/Vault/Summary/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }
        // query params
        if ($accountId !== null) {
            $queryParams['accountId'] = ObjectSerializer::toQueryValue($accountId);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVendorForCurrentCharacter
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20022
     */
    public function getVendorForCurrentCharacter($membershipType, $characterId, $vendorHash, $definitions = null)
    {
        list($response) = $this->getVendorForCurrentCharacterWithHttpInfo($membershipType, $characterId, $vendorHash, $definitions);
        return $response;
    }

    /**
     * Operation getVendorForCurrentCharacterWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20022, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVendorForCurrentCharacterWithHttpInfo($membershipType, $characterId, $vendorHash, $definitions = null)
    {
        $request = $this->getVendorForCurrentCharacterRequest($membershipType, $characterId, $vendorHash, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20022' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20022', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20022';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20022',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVendorForCurrentCharacterAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVendorForCurrentCharacterAsync($membershipType, $characterId, $vendorHash, $definitions = null)
    {
        return $this->getVendorForCurrentCharacterAsyncWithHttpInfo($membershipType, $characterId, $vendorHash, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVendorForCurrentCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVendorForCurrentCharacterAsyncWithHttpInfo($membershipType, $characterId, $vendorHash, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20022';
        $request = $this->getVendorForCurrentCharacterRequest($membershipType, $characterId, $vendorHash, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVendorForCurrentCharacter'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVendorForCurrentCharacterRequest($membershipType, $characterId, $vendorHash, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getVendorForCurrentCharacter'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getVendorForCurrentCharacter'
            );
        }
        // verify the required parameter 'vendorHash' is set
        if ($vendorHash === null || (is_array($vendorHash) && count($vendorHash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorHash when calling getVendorForCurrentCharacter'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/MyAccount/Character/{characterId}/Vendor/{vendorHash}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($vendorHash !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorHash' . '}',
                ObjectSerializer::toPathValue($vendorHash),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVendorForCurrentCharacterWithMetadata
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20033
     */
    public function getVendorForCurrentCharacterWithMetadata($membershipType, $characterId, $vendorHash, $definitions = null)
    {
        list($response) = $this->getVendorForCurrentCharacterWithMetadataWithHttpInfo($membershipType, $characterId, $vendorHash, $definitions);
        return $response;
    }

    /**
     * Operation getVendorForCurrentCharacterWithMetadataWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20033, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVendorForCurrentCharacterWithMetadataWithHttpInfo($membershipType, $characterId, $vendorHash, $definitions = null)
    {
        $request = $this->getVendorForCurrentCharacterWithMetadataRequest($membershipType, $characterId, $vendorHash, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20033' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20033', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20033';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20033',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVendorForCurrentCharacterWithMetadataAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVendorForCurrentCharacterWithMetadataAsync($membershipType, $characterId, $vendorHash, $definitions = null)
    {
        return $this->getVendorForCurrentCharacterWithMetadataAsyncWithHttpInfo($membershipType, $characterId, $vendorHash, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVendorForCurrentCharacterWithMetadataAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVendorForCurrentCharacterWithMetadataAsyncWithHttpInfo($membershipType, $characterId, $vendorHash, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20033';
        $request = $this->getVendorForCurrentCharacterWithMetadataRequest($membershipType, $characterId, $vendorHash, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVendorForCurrentCharacterWithMetadata'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVendorForCurrentCharacterWithMetadataRequest($membershipType, $characterId, $vendorHash, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getVendorForCurrentCharacterWithMetadata'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getVendorForCurrentCharacterWithMetadata'
            );
        }
        // verify the required parameter 'vendorHash' is set
        if ($vendorHash === null || (is_array($vendorHash) && count($vendorHash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorHash when calling getVendorForCurrentCharacterWithMetadata'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/MyAccount/Character/{characterId}/Vendor/{vendorHash}/Metadata/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($vendorHash !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorHash' . '}',
                ObjectSerializer::toPathValue($vendorHash),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVendorItemDetailForCurrentCharacter
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  int $vendorItemId A valid vendorItemIndex see [[GetVendorForCurrentCharacter]]. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20023
     */
    public function getVendorItemDetailForCurrentCharacter($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions = null)
    {
        list($response) = $this->getVendorItemDetailForCurrentCharacterWithHttpInfo($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions);
        return $response;
    }

    /**
     * Operation getVendorItemDetailForCurrentCharacterWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  int $vendorItemId A valid vendorItemIndex see [[GetVendorForCurrentCharacter]]. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20023, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVendorItemDetailForCurrentCharacterWithHttpInfo($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions = null)
    {
        $request = $this->getVendorItemDetailForCurrentCharacterRequest($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20023' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20023', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20023';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20023',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVendorItemDetailForCurrentCharacterAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  int $vendorItemId A valid vendorItemIndex see [[GetVendorForCurrentCharacter]]. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVendorItemDetailForCurrentCharacterAsync($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions = null)
    {
        return $this->getVendorItemDetailForCurrentCharacterAsyncWithHttpInfo($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVendorItemDetailForCurrentCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  int $vendorItemId A valid vendorItemIndex see [[GetVendorForCurrentCharacter]]. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVendorItemDetailForCurrentCharacterAsyncWithHttpInfo($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20023';
        $request = $this->getVendorItemDetailForCurrentCharacterRequest($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVendorItemDetailForCurrentCharacter'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  int $vendorItemId A valid vendorItemIndex see [[GetVendorForCurrentCharacter]]. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVendorItemDetailForCurrentCharacterRequest($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getVendorItemDetailForCurrentCharacter'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getVendorItemDetailForCurrentCharacter'
            );
        }
        // verify the required parameter 'vendorHash' is set
        if ($vendorHash === null || (is_array($vendorHash) && count($vendorHash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorHash when calling getVendorItemDetailForCurrentCharacter'
            );
        }
        // verify the required parameter 'vendorItemId' is set
        if ($vendorItemId === null || (is_array($vendorItemId) && count($vendorItemId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorItemId when calling getVendorItemDetailForCurrentCharacter'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/MyAccount/Character/{characterId}/Vendor/{vendorHash}/Item/{vendorItemId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($vendorHash !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorHash' . '}',
                ObjectSerializer::toPathValue($vendorHash),
                $resourcePath
            );
        }
        // path params
        if ($vendorItemId !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorItemId' . '}',
                ObjectSerializer::toPathValue($vendorItemId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVendorItemDetailForCurrentCharacterWithMetadata
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  int $vendorItemId A valid vendorItemIndex see [[GetVendorForCurrentCharacter]]. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20034
     */
    public function getVendorItemDetailForCurrentCharacterWithMetadata($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions = null)
    {
        list($response) = $this->getVendorItemDetailForCurrentCharacterWithMetadataWithHttpInfo($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions);
        return $response;
    }

    /**
     * Operation getVendorItemDetailForCurrentCharacterWithMetadataWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  int $vendorItemId A valid vendorItemIndex see [[GetVendorForCurrentCharacter]]. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20034, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVendorItemDetailForCurrentCharacterWithMetadataWithHttpInfo($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions = null)
    {
        $request = $this->getVendorItemDetailForCurrentCharacterWithMetadataRequest($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20034' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20034', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20034';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20034',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVendorItemDetailForCurrentCharacterWithMetadataAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  int $vendorItemId A valid vendorItemIndex see [[GetVendorForCurrentCharacter]]. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVendorItemDetailForCurrentCharacterWithMetadataAsync($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions = null)
    {
        return $this->getVendorItemDetailForCurrentCharacterWithMetadataAsyncWithHttpInfo($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVendorItemDetailForCurrentCharacterWithMetadataAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  int $vendorItemId A valid vendorItemIndex see [[GetVendorForCurrentCharacter]]. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVendorItemDetailForCurrentCharacterWithMetadataAsyncWithHttpInfo($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20034';
        $request = $this->getVendorItemDetailForCurrentCharacterWithMetadataRequest($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVendorItemDetailForCurrentCharacterWithMetadata'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  int $vendorHash A valid vendorHash. (required)
     * @param  int $vendorItemId A valid vendorItemIndex see [[GetVendorForCurrentCharacter]]. (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVendorItemDetailForCurrentCharacterWithMetadataRequest($membershipType, $characterId, $vendorHash, $vendorItemId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getVendorItemDetailForCurrentCharacterWithMetadata'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getVendorItemDetailForCurrentCharacterWithMetadata'
            );
        }
        // verify the required parameter 'vendorHash' is set
        if ($vendorHash === null || (is_array($vendorHash) && count($vendorHash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorHash when calling getVendorItemDetailForCurrentCharacterWithMetadata'
            );
        }
        // verify the required parameter 'vendorItemId' is set
        if ($vendorItemId === null || (is_array($vendorItemId) && count($vendorItemId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendorItemId when calling getVendorItemDetailForCurrentCharacterWithMetadata'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/MyAccount/Character/{characterId}/Vendor/{vendorHash}/Item/{vendorItemId}/Metadata/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }
        // path params
        if ($vendorHash !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorHash' . '}',
                ObjectSerializer::toPathValue($vendorHash),
                $resourcePath
            );
        }
        // path params
        if ($vendorItemId !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorItemId' . '}',
                ObjectSerializer::toPathValue($vendorItemId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVendorSummariesForCurrentCharacter
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20021
     */
    public function getVendorSummariesForCurrentCharacter($membershipType, $characterId, $definitions = null)
    {
        list($response) = $this->getVendorSummariesForCurrentCharacterWithHttpInfo($membershipType, $characterId, $definitions);
        return $response;
    }

    /**
     * Operation getVendorSummariesForCurrentCharacterWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20021, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVendorSummariesForCurrentCharacterWithHttpInfo($membershipType, $characterId, $definitions = null)
    {
        $request = $this->getVendorSummariesForCurrentCharacterRequest($membershipType, $characterId, $definitions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20021' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20021', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20021';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20021',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVendorSummariesForCurrentCharacterAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVendorSummariesForCurrentCharacterAsync($membershipType, $characterId, $definitions = null)
    {
        return $this->getVendorSummariesForCurrentCharacterAsyncWithHttpInfo($membershipType, $characterId, $definitions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVendorSummariesForCurrentCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVendorSummariesForCurrentCharacterAsyncWithHttpInfo($membershipType, $characterId, $definitions = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20021';
        $request = $this->getVendorSummariesForCurrentCharacterRequest($membershipType, $characterId, $definitions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVendorSummariesForCurrentCharacter'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $characterId (required)
     * @param  bool $definitions Include definitions in the response. Use while testing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVendorSummariesForCurrentCharacterRequest($membershipType, $characterId, $definitions = null)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling getVendorSummariesForCurrentCharacter'
            );
        }
        // verify the required parameter 'characterId' is set
        if ($characterId === null || (is_array($characterId) && count($characterId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $characterId when calling getVendorSummariesForCurrentCharacter'
            );
        }

        $resourcePath = '/Destiny/{membershipType}/MyAccount/Character/{characterId}/Vendors/Summaries/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitions !== null) {
            $queryParams['definitions'] = ObjectSerializer::toQueryValue($definitions);
        }

        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($characterId !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($characterId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchDestinyPlayer
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $displayName A valid display name to search for. (required)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse2004
     */
    public function searchDestinyPlayer($membershipType, $displayName)
    {
        list($response) = $this->searchDestinyPlayerWithHttpInfo($membershipType, $displayName);
        return $response;
    }

    /**
     * Operation searchDestinyPlayerWithHttpInfo
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $displayName A valid display name to search for. (required)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse2004, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchDestinyPlayerWithHttpInfo($membershipType, $displayName)
    {
        $request = $this->searchDestinyPlayerRequest($membershipType, $displayName);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse2004' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse2004', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse2004';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse2004',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchDestinyPlayerAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $displayName A valid display name to search for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchDestinyPlayerAsync($membershipType, $displayName)
    {
        return $this->searchDestinyPlayerAsyncWithHttpInfo($membershipType, $displayName)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchDestinyPlayerAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $displayName A valid display name to search for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchDestinyPlayerAsyncWithHttpInfo($membershipType, $displayName)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse2004';
        $request = $this->searchDestinyPlayerRequest($membershipType, $displayName);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchDestinyPlayer'
     *
     * @param  \Bungie\D1\Model\BungieMembershipType $membershipType The type of account for which info will be extracted. (required)
     * @param  string $displayName A valid display name to search for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchDestinyPlayerRequest($membershipType, $displayName)
    {
        // verify the required parameter 'membershipType' is set
        if ($membershipType === null || (is_array($membershipType) && count($membershipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membershipType when calling searchDestinyPlayer'
            );
        }
        // verify the required parameter 'displayName' is set
        if ($displayName === null || (is_array($displayName) && count($displayName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $displayName when calling searchDestinyPlayer'
            );
        }

        $resourcePath = '/Destiny/SearchDestinyPlayer/{membershipType}/{displayName}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($membershipType !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membershipType),
                $resourcePath
            );
        }
        // path params
        if ($displayName !== null) {
            $resourcePath = str_replace(
                '{' . 'displayName' . '}',
                ObjectSerializer::toPathValue($displayName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setItemLockState
     *
     * @param  \Bungie\D1\Model\inline_object_3 $inlineObject3 inlineObject3 (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20038
     */
    public function setItemLockState($inlineObject3 = null)
    {
        list($response) = $this->setItemLockStateWithHttpInfo($inlineObject3);
        return $response;
    }

    /**
     * Operation setItemLockStateWithHttpInfo
     *
     * @param  \Bungie\D1\Model\inline_object_3 $inlineObject3 (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20038, HTTP status code, HTTP response headers (array of strings)
     */
    public function setItemLockStateWithHttpInfo($inlineObject3 = null)
    {
        $request = $this->setItemLockStateRequest($inlineObject3);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20038' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20038', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20038';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20038',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setItemLockStateAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\inline_object_3 $inlineObject3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setItemLockStateAsync($inlineObject3 = null)
    {
        return $this->setItemLockStateAsyncWithHttpInfo($inlineObject3)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setItemLockStateAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\inline_object_3 $inlineObject3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setItemLockStateAsyncWithHttpInfo($inlineObject3 = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20038';
        $request = $this->setItemLockStateRequest($inlineObject3);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setItemLockState'
     *
     * @param  \Bungie\D1\Model\inline_object_3 $inlineObject3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setItemLockStateRequest($inlineObject3 = null)
    {

        $resourcePath = '/Destiny/SetLockState/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($inlineObject3)) {
            $_tempBody = $inlineObject3;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setQuestTrackedState
     *
     * @param  \Bungie\D1\Model\inline_object_4 $inlineObject4 inlineObject4 (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20039
     */
    public function setQuestTrackedState($inlineObject4 = null)
    {
        list($response) = $this->setQuestTrackedStateWithHttpInfo($inlineObject4);
        return $response;
    }

    /**
     * Operation setQuestTrackedStateWithHttpInfo
     *
     * @param  \Bungie\D1\Model\inline_object_4 $inlineObject4 (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20039, HTTP status code, HTTP response headers (array of strings)
     */
    public function setQuestTrackedStateWithHttpInfo($inlineObject4 = null)
    {
        $request = $this->setQuestTrackedStateRequest($inlineObject4);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20039' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20039', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20039';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20039',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setQuestTrackedStateAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\inline_object_4 $inlineObject4 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setQuestTrackedStateAsync($inlineObject4 = null)
    {
        return $this->setQuestTrackedStateAsyncWithHttpInfo($inlineObject4)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setQuestTrackedStateAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\inline_object_4 $inlineObject4 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setQuestTrackedStateAsyncWithHttpInfo($inlineObject4 = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20039';
        $request = $this->setQuestTrackedStateRequest($inlineObject4);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setQuestTrackedState'
     *
     * @param  \Bungie\D1\Model\inline_object_4 $inlineObject4 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setQuestTrackedStateRequest($inlineObject4 = null)
    {

        $resourcePath = '/Destiny/SetQuestTrackedState/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($inlineObject4)) {
            $_tempBody = $inlineObject4;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transferItem
     *
     * @param  \Bungie\D1\Model\inline_object $inlineObject inlineObject (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return \Bungie\D1\Model\InlineResponse20035
     */
    public function transferItem($inlineObject = null)
    {
        list($response) = $this->transferItemWithHttpInfo($inlineObject);
        return $response;
    }

    /**
     * Operation transferItemWithHttpInfo
     *
     * @param  \Bungie\D1\Model\inline_object $inlineObject (optional)
     *
     * @throws \Bungie\D1\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @return array of \Bungie\D1\Model\InlineResponse20035, HTTP status code, HTTP response headers (array of strings)
     */
    public function transferItemWithHttpInfo($inlineObject = null)
    {
        $request = $this->transferItemRequest($inlineObject);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Bungie\D1\Model\InlineResponse20035' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bungie\D1\Model\InlineResponse20035', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bungie\D1\Model\InlineResponse20035';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bungie\D1\Model\InlineResponse20035',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transferItemAsync
     *
     * 
     *
     * @param  \Bungie\D1\Model\inline_object $inlineObject (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferItemAsync($inlineObject = null)
    {
        return $this->transferItemAsyncWithHttpInfo($inlineObject)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transferItemAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Bungie\D1\Model\inline_object $inlineObject (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferItemAsyncWithHttpInfo($inlineObject = null)
    {
        $returnType = '\Bungie\D1\Model\InlineResponse20035';
        $request = $this->transferItemRequest($inlineObject);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \Psr\Http\Message\ResponseInterface $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transferItem'
     *
     * @param  \Bungie\D1\Model\inline_object $inlineObject (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function transferItemRequest($inlineObject = null)
    {

        $resourcePath = '/Destiny/TransferItem/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($inlineObject)) {
            $_tempBody = $inlineObject;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
